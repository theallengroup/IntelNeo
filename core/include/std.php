<?php	
/** $mydir is a simple but effective way of keeping session stuff separated from each application. */
global $std_env,$std_views,$std_error_log,$timestart,$mydir,$std_usr_data,$std_rel;

/*
$std_base_dir=explode('/',str_replace("\\",'/',__FILE__));
unset($std_base_dir[count($std_base_dir)-1]);
$std_base_dir = implode('/',$std_base_dir);
echo($std_base_dir);
define('STD_LOCATION',$std_base_dir."/../");
 */
//echo($_SERVER['PHP_SELF']);
include(STD_LOCATION."include/init.php");

/** 
 * \brief STD Web Application Framework : a simple way of managing a table, with all the CRUD characteristcs found in popular packages.
 *
 * 
 \mainpage STD SYSTEM Documentation and Reference Manual

 \section intro_sec Introduction

 The STD web application framework is a helper for CRUD (Create, Retrieve, Update & Delete) Applications.
 it allows rapid prototyping of web applications in PHP.

 \section install_sec Requirements
 	PHP >= 4.3
 	Mysql >= 3.23
	Apache >= 1.3

	Appserv has all of these bundled
       
 \section install_sec Installation
       
 \subsection step1 Appserv

 1. download Appserv 4.4a from appservnetwork.com and install it into the default directory
 2. make sure the mysql user name is root and the password is "".
 3. copy the application folder into the /appserv/www/ folder
 4. head http://localhost/projectX.X.X.X/ where X.X.X.X is the current version number.

 a project list should be found.
 to install specific applications do the following
 \subsection specific Installing your Application

 if you have an app generated by the program, it is recommended you create a file called install.sql in [your_app]/install/
 given such file, run the mysql command line, and dump it into the console.
 if any errors should appear, you can do this:

 mysql -u user -h host -p < your_file.sql > log.txt

 and check the log.

 \subsection conf Configuration
 
 see /core/cf/conf.php

 \subsection upgrading Upgrade
	usually, just replacing the ./core folder will do, if you need to keep running both cores.
       edit STD_LOCATION in [your_app]/index.php	


 \subsection todo [Important] Stuff that Isn't done yet

 * assumes STD_LOCATION
 *
	\todo 001 sort seems to be injectable!, must validate within valid fields, and then put ID if the field provided isn't valid
	 \todo 233 allow form redisplay, with invalid input
       \todo 234 make some proofs of concepts.

 * \todo boolean datatype: list y/n
 *
	 * intelligent privileges
	 *
	 * 9901 allow action to have special parameter info, so privileges can be "programable" from UI
	 * mod/act:a=4,b=6  ... etc
	 * that info is stored somewhere act_info?
	 * and then acted upon, this is necesary to:
	 * allow some parts of a view to be visible to some certain users, without creating 
	 * a lot of views:
	 * for instance, I want some users not to have any HBM capabilities, but root should have them always,
	 * so a prvilege could be: view:new>root=1
	 * and view:new>root=0 for everyone else
	 * then , on view:new, I will read the root variable, and show the form, when root==1
	 * applications are endless, the base: configurability.

 *
 * 9900 add privilege
 *
 * \todo [important]: action.register_privileges:
 *  for a given action: usr/edit_user -> the following privileges must be enabled: 
 *  catch: this might or might not be enabled.
 *  if the user is autentified, and is redirected, but has no permitio, we can assume its iour fault 
 *  (removed him from XYZ/edit item/5)
	 *  therefore, we should provide (a) a blank screen
	 *  indicating, that the user is gone for too long, but is not "not autorized" but autorized! (and has to go trough
	 *  the whole process again.)
	 * 
	 * searching in the views makes sence, because its static (kindof), hard coded,
	 * however, which privileges derive from a,b, or c are almost unpredictable
	 *
	 * FOR predictable elements:
	 * allow: setting a privileges allowed per role per action, that is PRIVILEGES NOT IN std::MENU().
	 *
	 * todo2: save the whole GET, not just mod and ac, because we loose impotrant data like record number ID, search
	 * stuff, etc.
	 *
	 * GET__<key>
	 * restore: take all GET__ and replace by "".
	 * remove current "get"
	 *
	 *
	 *
	 * \todo fix adv option system
	 * \todo
	 *
	 * install system 
	 *
	 * cfe:(global) Configuration Editor
	 * 	- 1. select site name: x,y,z
	 * 	-    glob's config
	 *	-    ->
	 *	- edit selected config file
	 *
	 *
	 *
	 * 	- 2. create site (from [list] ),OK
	 *	-   ->
	 *	- edit what you just created
	 *	[new site]
	 *
	 *	cfe:module
	 *	API: create_from_config(file,file2)
	 *
	 * \todo 1126 event onGenerate
	 * \todo 1126 event onInstall
	 * if(no sites that match ($_SERVER[http_host])){
	 *	1. create new config from default
	 *	2. edit config
	 * }
	 *
	 * evu
	 * 1.
	 *
	 * \todo 001 help in checklist for EACH item.
	 * \todo include form.php ? only when actually USED ??its almost always used...
	 * \todo allow detection, and user setting. standard language stuff.
	 * 
	 *
	 * \todo on delete r u sure you'll delete: xxx with gender
	 * belongs to the allows posibilities in box:style :: iframe,shadow,round:
	 * \todo put more. styles
		
	 * \todo allow template.headerinfo, so we can see the names of the fields, in the field AND in the template.
	 * 
	 * \todo make a list of error codes, and equivalents.
	 * \todo allow show/hide debug info
	 * \todo on delete r u sure you'll delete: xxx with gender
	 @code
	 //must use this!
<BUTTON type=submit name=abutton value="html4 button test">
<IMG ALT="alt-demo" 
src="http://www.physics.gla.ac.uk/AIcons/Buttons/startrek.gif">
<br>
Here's some text<br> for <br>the button element.
</BUTTON>
@endcode

	\author f3l (auditor400@gmail.com)
	
	it should preffix every SESSION operation.	
       	* */

class std extends db{ 
	var $enable_auth='0';
	var $enable_safe_delete='0';
	var $safe_delete_expr='1=1';
	var $enable_edit2_redirect='1';
	var $enable_new2_redirect='1';
	var $default_money_filter='money';
	var $b2l_default_action='all_b2l';
	var $version='0.2.7.6';
	/** 
	 * @ingroup header
	 *
	 * disable headers is an array of functions names, with aa() formatting that will disable std::head() and std::foot() 
	 * output (useful for excel outpout, rss output  and for new2, edit2, and everything tyou want to send stuff
	 * to the NEXT page (that is, of you need a function to use heade(Location) you need to add such function to 
	 * the disable headers list.
	 * @see enable_header
	 * @see std::head
	 * @see std::foot
	 * ))*/
	var $disable_headers=array(
		'all_b2l'=>'all_b2l',
		'all_new2'=>'all_new2',
		'all_delete2'=>'all_delete2',
		'all_delete_selected'=>'all_delete_selected',
		'all_delete'=>'all_delete',
		'edit2'=>'edit2',//sufre about this line???
		'all_edit2'=>'all_edit2',
		'all_xls'=>'all_xls',
		'all_load_from_excel'=>'all_load_from_excel',
	);
	var $mod_get_kids_fields=array();//might be ALL
	var $xls_path = 'excel_files/';
	var $use_table=1;///< code modules must set this to 0
	var $nomodel=0;///< yes we do have model
	var $default_login_module='usr';///< code modules must set this to 0
	var $shadow_config=array(
		'warning_location'=>'warning.gif',
		'error_image_location'=>'error.gif',
		'menu'=>'shadow',
		'form'=>'shadow',
		'form_from_fields'=>'iframe',
		'delete'=>'banded',
		'msg'=>'round',
	);
	/** this is the default shadow object */
	var $shadow_object=null;
	/** default style indicates the kind of borders you want arround some elements @see std::ed() */
	var $default_style='shadow';		
	/** default_edit_action what happens wqhen you click on the "name" link on ml() (used to be view:edit_all) */
	var $default_edit_action = 'all_edit';	
	/** default_create_action what happens when you click on the ADD link on ml() (used to be view:new) */
	var $default_create_action = 'all_new';	
	/** this module's relationships */
	var $rel=array();
	/** name says it all */
	var $added_fields_count=0;
	/** <whether or not to display messages on new2, et al, \\todo et al*/
	var $silent=0;					
	/** don't mess with this one @see std::filter_trim*/
	var $default_trim_append_string='...';
	/** for longer strings, @see std::filter_trim */
	var $default_trim_length=40;	
	/** function name */
	var $mask_filter='mask';
	/** function name */
	var $default_filter='trim';
	/** function name (keeping this here allows you to easily delete or override this behavior.)*/
	var $date_filter='date';		
	/** adds links to view() */
	var $link_filter='link';		
	/** make your own highlight filter (or override it with 'none' so no highlighting is disabled) */
	var $default_highlight_filter='highlight_search_terms';
	/** don't mess with this (seriously) */
	var $view_handler_function='view';	
	/** menu is by default ENABLED, to disable menu (and other outputs see std::head() std::foot() and std::$disable_headers) */
	var $show_menu=1;			

	///@defgroup table Table Vars
	///@{
	
	/** this is the name of the SQL field that has the key of the table. */
	var $id='id';				
	/**  NOT:the first varchar field of the table */
	var $name='ERROR_std';			
	/**  identiying field / default:the first varchar field of the table */
	var $ifield='STD_NO_IFIELD';			
	/** a structure: @see std::filter_highlight_search_terms */
	var $current_search=array();	
	/** the name of the table (DO NOT USE), use instead std::program_name() or std::get_table_name() */
	var $table='STD_NO_TABLE';		
	///@}
	/**  usr by default, this is the one that handles the mod=="" requests */
	var $default_module='usr';		
	/** <default action indicates what action must be used when no actin is given (useful in places like usr_model::login(), where no previous parameters are set) */
	var $default_action='all';		
	/** restrictions allow me to give the uesr permissions to stuff he would normally have not permission to, like the login screen, etc */
	var $restrictions=array('allow'=>array(),'deny'=>array());
	/** public modules indicate those modules that can be accessd by everyone (however, these modules MUST have public actions, or trhe Guest will be denied access).*/
	var $public_modules=array('skin'=>'skin');		
	/** form object, for Get_ed et al*/
	var $f=null;				
	/** when a user goes away for a while, and the sessio is over, or when you save a link, you need to re-login , re-logging in, is a redirect. */
	var $is_redirect=0;			
	/** this sets teh default where clause for the kids you wanna show 
	 * (for instance, only the last week logs, or only the items that something to do with ssid(), etc)
	 * @see std::mod_get_kids()
	 * usage:
	 * @code
	 * $this->default_mod_get_kids_restrict = ' field = value '
	 * @endcode
	 * where field is a valid fully qualified sql field, and value, si a valid SQL valid expression (for strings, use '' )
	 * */
	var $default_mod_get_kids_restrict='';
	/** 
	 * allows you to set a module which we send people to when they have a login error, that is
	 * the are unauthorized to enter, AND they have no other permissions (not previously logged in)
	 * should be set in &gt;project_name&lt;_base.php
	 * */

	var $login_module='usr';
	/**
	 * returns a dataset, as outputed from db::q2obj, which contains all of the "kids", which are items that belong to a certain parent
	 * usually
	 * @param $where_clause is the sql that I assume you need to create the query
	 *
	 * you may not need to re-implement, if you use these variables:
	 *
	 * @see std::mod_get_kids_fields
	 * @see std::default_mod_get_kids_restrict
	 * */
	function mod_get_kids($where_clause){
		if($this->mod_get_kids_fields=='all'){
			$this->mod_get_kids_fields=array_keys($this->fields);
		}
		if(count($this->mod_get_kids_fields)==0){
			$this->mod_get_kids_fields[]=$this->id;
			$this->mod_get_kids_fields[]=$this->ifield;
		}
		$f=array();
		foreach($this->mod_get_kids_fields as $fname){
			$f[$fname]=$this->fields[$fname];
		}
		if($this->default_mod_get_kids_restrict!=''){
			$where_clause.=' AND '.$this->default_mod_get_kids_restrict;
		}
		$q=$this->foreign_select(array('fields'=>$f,'restrict'=>$where_clause,'get_fid'=>0));
		$this->fs_options=$q;
		#d2($q);
		$this->ml_options=array('fields'=>$this->fields);
		//$this->fs_options=$q;
		$a = $this->q2obj($q['sql']);
		$a = $this->filter_trough($a,array('trim','mask'));
		//p2($this->fs_options);
		return($a);
	}

	/**
	 * @defgroup header_management Header Management
	 * */
	//@{

	/** @brief
	 * counteracts the disable headers directive
	 *
	 * @see std::enable_header
	 * */
	function enable_header($header){
		unset($this->disable_headers[$header]);
	
	}
	/**@brief  
	 * disallow any output from std::head()
	 *
	 * when you work with the class, it is always assumed that you sish to output html, however
	 * if you DONT want to emit HMTL, you can always disable HTML output
	 * this is useful when you need to call the php function header(), or when you need
	 * to output stuff in a different format, like XML, SVG, etc
	 * also consider that there is another mechanism to do this, which is ?__output_type=XXX
	 * where XXX is not HTML

	 * @see std::foot
	 * @see std::head
	 * @see std::disable_header
	 * */
	function disable_header($header){
		$this->disable_headers[$header]=$header;
	
	}
	//@}

	/** \brief adds a module to the list of those freely accesable
	 *
	 * public modules are those that can be accesed without previous authorization, like, the usr module
	 * (it would be bad if you had to be authorized to "login")
	 * */
	function add_public_module($module_name){
		global $mydir;
		$this->public_modules[$module_name]=$module_name;
		$_SESSION[$mydir]['usr']['_priv_mods'][$module_name]=$module_name;
	}


	/**
	 * @defgroup behavior Behavior
	 * */
	//@{
	/**
	 * @param $context : the whole VIEW object.
	 * */
	function fields_transform($fields,$context){
		$return_fields=array();

		foreach($fields as $k=>$field){
			if(array_key_exists('behave',$field)){
				$behavior='bh_'.$field['behave'];
				if(array_key_exists($behavior,$this->get_func_list('bh_'))){
					$return_fields[$k] = $this->$behavior($field,$context);
					$this->log($field['name'] . ' was touched by: '.$behavior,'BEHAVIOR');					
				}else{
					$this->error('missing behavior:'.$behavior.' on field:'.$field['name']);
					die(0);
				}
			}else{
				$return_fields[$k] = $field;
			}
		}
		return($return_fields);
	}
	/**
	 * NEW views have a marker called: if_not_exists, which is short for if_not_exists_=>create, 
	 * which implies a INSERT form, not a UPDATE form.
	 * */
	function bh_std_insert_date($field,$context){
		if(array_key_exists('if_not_exists',$context) && $context['if_not_exists'] =='create' ){
			$field = $this->bh_std_update_date($field,$context);
		}
		return($field);
	}
	function bh_std_update_date($field,$context){
		$field['type']='label';
		$field['value']=date('Y-m-d H:i:s');
		return($field);
	}
	/** @todo 92q84372 implement this */
	function counter2table($field_name){
		$p = preg_match('/std_(.*)_count/',$field_name,$match);
		return($match[1]);
	}
	/** @todo 92q84372_a implement this */
	function bh_std_count($field,$context){
		$c = $this->q2obj('SELECT count(*) as c FROM '.$this->counter2table($field['name']).' WHERE '.$this->table.'_'.$this->id.'  = \''.$context['data'][0][$this->id].'\'');
		$field['value'] = $c[0]['c'];
		return($field);	
	}
	/** 
	 * standard behavior for fields (so nothing)
	 * copy this, for your new behaviors.
	 * */
	function bh_std_none($field,$context){
		return($field);	
	}
	//@}

	/**
	 * @defgroup simple Simple API
	 *
	 * */
	//@{
	/** 
	 * returns a form object which is useful for creating screens that promt the user to do specific actions 
	 * on a given module

	- options.title,
	- options.action
	- options.type:list |checklist
	*/
	function get_local_modules_form($options=array()){
		$ac='Aceptar';
		$type = 'list';
		$title='@default';
		if(count($options)>0){
			extract($options);
		}

		if($title == '@default'){
			if($type == 'list'){
				$title='Seleccione un M&oacute;dulo';
			}else{
				$title='Seleccione los M&oacute;dulos';
			}
		}
		$f = new form();
		$f->strings = array(
			'tables'=>'M&oacute;dulos',
			'help_tables'=>$title,
		);
		$f->set_title($title);
		$op = array();
		foreach($this->get_local_modules() as $m){
			$m = basename($m,'.controller.php');
			$d = $this->load_file($m);
			$op[$d->program_name()]=$d->i18n('table_plural');
		}
		$f->add_field(array('name'=>'tables','type'=>$type,'options'=>$op,'values'=>array_keys($op),'check_all'=>1));
		$f->add_hidden_field('mod',$_GET['mod']);
		$f->add_submit_button(array('label'=>$action,'action'=>$_GET['ac']));
		return($f);
	}

	/** 
	 * simple list
	 * replaces dsl
	 * */
	function slist($sql_condition='1=1',$fields='@none',$action='@default'){
		if($action=='@default'){
			$action='all_edit';
		}
		if($fields=='@none'){
			$fields=array(
				$this->id=>$this->fields[$this->id],
				$this->ifield=>$this->fields[$this->ifield]);
		}

		$old_ifield=$this->ifield;

		$filter='link';
		foreach($fields as $k => $field){
			if($k == 'STD_NO_IFIELD'){
				unset($fields[$k]);
				$this->ifield=$this->id;
			}
		}

		$old=$this->default_edit_action;
		$this->default_edit_action=$action;
		$d=$this->dsl($fields, $sql_condition,array(),'table_plural',$filter);
		$this->default_edit_action=$old;
		$this->ifield=$old_ifield;
		return($d);
	}
	/** @see std::slist() */
	function e_slist($sql_condition='1=1',$fields='@none',$action='@default'){
		$this->shadow($this->slist($sql_condition,$fields,$action));
	}
	/** 
	 * @see std::form_from_fields
	 * returns a form object,
	 * uses $this->f 
	 * */
	function get_form_from_fields($ac,$fields,$options){
		global $i18n,$i18n_std;
		if(!array_key_exists('title',$options)){
			$options['title']='notitle';
		}
		$title=$options['title'];
		$f=array();
		if($fields!='all'){
			///\todo 261 make this a func 
			foreach($fields as $k=>$f1){
				$f[$f1]=$this->fields[$f1];
			}
		}else{
			$f=$this->view_expand($fields);
		}
		if($title=='notitle'){
			$tt=$i18n[$this->name]['table_title'];
		}else{
			$tt=$title;
		}	
		#echo($ac);	
		#add privilege
		$this->privilege_manager->add_privilege(array(
			'action'=>$this->mod_and_ac($_GET['mod'],$ac),
			'privilege_name'=>$i18n[$this->table]['table_plural'],
			# Guest, until otherwise proven.
			'role_name'=>$i18n_std["roles"]["guest"],
		));
		$this->get_ed(array(
		#	'template_file'=>$options['template_file'],
			'width'=>$options['width'],
			'method'=>$options['method'],
			'actions'=>array($ac),
			'rawtitle'=>$tt,
			'data'=>'',
			'style'=>$this->shadow_config['form_from_fields'],
			'fields'=>$f,
		));
		return($this->f);
	}
	/**
	 * \todo 1125 this function is very limited, and not very configurable, making it useless, improve it.
	 *
	 * WARNING:THIS ALLOWS (grants privilege to current user) ANYTHING YOU SET AS ACTION.
	 * @param $ac: requires no MOD
	 * @param $fields: a list of KEYS (not actual fields.), or the word "all"
	 * @param $options an array with: title,width
	 * @see std::get_form_from_fields
	 * */
	function form_from_fields($ac,$fields,$options){
		$f = $this->get_form_from_fields($ac,$fields,$options);
		$this->shadow($f->out(),$this->shadow_config['form_from_fields'],'center');
	}
	/** 
	 * make current link
	 * 
	 * @todo 3002 make function get view:this or this
	 * */
	function mkl($options,$text){
		if($this->current_action=='view'){
			$dy=$this->current_action.':'.$this->current_view;
		}else{
			$dy=$this->current_action;
		}
		$dz = array_merge(array('mod'=>$this->program_name(),'ac'=>$dy),$options);
		return($this->make_link($dz,$text));
	}
	/**
	 * @todo 8999 implement
	 */
	
	function select($link_options,$text,$restrict){
		
	}

	/** @brief  display simple list, like table() but smarter
	 *
	 * \todo 1302 privilege. on VIEW: check if view exists.
	 * 
	 * use case: I want a list of all the users, but no password on it
	 *
	 * @param $filter a filter function
	 *
	 * @code
	 * $m3=$this->load_file('usr');
	 * $m3->e_dsl('all','1=1',array('password'));
	 * @endcode
	 *
	 * @param $fields a \ref field_structure "Field Structure"
	 * @param $restrict sql where clause
	 * @param $exclude_fields \ref field_structure fields that *WON'T* be on the view
	 * @param $title title is an \ref i18n_key
	 * @param $filter a \ref filter "Filter Function Name"
	 *
	 * */

	function dsl($fields='all',$restrict=' 1=1 ',$exclude_fields=array(),$title='table_plural',$filter='none'){
		$fields=$this->view_expand($fields);
		$f=array();
		//remove ecluded fields
		///@todo 1129 allow eclude_fields and allcombination to be used in other places, as a replacement for field repetition!
		///and fields_exclude()
		$h=array();
		foreach($fields as $k=>$field){
			if(!in_array($k,$exclude_fields)){
				$f[$k]=$field;
				$h[$k]=$this->fi($k);
			}
		}

		$title=$this->get_i18n_text($title,'');
		$q=$this->foreign_select(array('fields'=>$f,'restrict'=>$restrict,'get_fid'=>0));
		$this->fs_options=$q;	
		#dbg p2($q["sql"]);
		$items=$this->q2obj($q['sql']);

		if($filter!='none'){
			$items=$this->filter_trough($items,$filter);
		}

		return($this->table($items,$h,array(
			'style'=>'list',
			'cellspacing'=>0,
			'border'=>0,
			'cellspadding'=>2,
			'title'=>$title
		)));
	}
	
	/** 
	 * @brief echoes the content of dsl() 
	 * @see std::dsl
	 * \todo 1301 remove 1=1 where possible
	 * */
	
	function e_dsl($fields='all',$restrict=' 1=1 ',$exclude_fields=array(),$title='table_plural',$filter='none'){
		$this->shadow($this->dsl($fields,$restrict,$exclude_fields,$title,$filter),'shadow');
	}
	

	//@}

	/** \defgroup i18n Internationalization (i18n)
	 *
	 * i18n is vey important for web applications, therefore i18n support is added by default
	 * to all generated applications, if you need to change the texts in i18n, move to
	 * 
	 * [your_app]/i18n/
	 * there you will find folders like:
	 * 
	 * /ES/
	 * /EN/
	 * 
	 * etc.
	 *
	 * each of these folders have information about a language, ES=Spanish, EN=English, etc
	 * in any of those folders, you will find files like these:
	 * [table_name].i18n.php
	 * such files contain a PHP array (editable trough the PHP array editor) whicih have all the information
	 * related to [table_name].
	 * such information is usually entered at the program generation screen.
	 *
	 * it is highly recomended that all of your strings, are stored here.
	 *
	 * if a string will be used by m,ore than one table, it is recomemded that such strings are saved in
	 * [app_name]/i18n/[LANG].i18n.php
	 * that is the best way to avoid repetition.
	 *
	 * */
	//@{

	/**
	 * \page i18n_key I18n Key
	 *
	 * i18n is handles trough a PHP array.
	 * an i18n keym, is a key from that array.
	 * the key may be overrriden by the user module.
	 *
	 * -IS STATIC
	 * this looks for i18n keys inside the i18n_std and the i18n[table]arrays, for keys matchng prefix.key 
	 * it exists mainly for buttons.
	 * @param $key the key of the element in the array(s)
	 * @param $prefix what you add to the $key.
	 * */
	function get_i18n_text($key,$prefix='form_'){
		global $i18n,$i18n_std;
		#echo(b2());
		if(is_array($i18n) && !array_key_exists($this->table,$i18n)){
			if(array_key_exists($prefix.$key,$i18n_std['list'])){
				return($i18n_std['list'][$prefix.$key]);
			}else{
				std::log("Warning: could find I18N array for:".print_r($this->table,true).' on key:'.$key,'WARNING');
				return('LOCAL_ERR:['.$key.']');
			}
		}else{
			if(is_array($i18n[$this->table]) &&  array_key_exists($prefix.$key,$i18n[$this->table])){
				return($i18n[$this->table][$prefix.$key]);
			}elseif(array_key_exists($prefix.$key,$i18n_std['list'])){
				return($i18n_std['list'][$prefix.$key]);
			}else{
				$this->log("Uknown i18n key:".$prefix.$key.' @'.$this->table.' nor in i18n_std','WARNING');
				return("ERR_".$key);
			}
		}
	}

	/**
	 * Returns a list of i18n labels, for the current table fields.
	 * in a suitable way for view::ml()
	 * THIS REMAINS IN STD, same as get_i8n_list ?
	 * 
	 * alias?
	 *
	 * */
	function get_headers(){
		global $i18n;
		$f=array();
		foreach($this->fields as $k=>$field){
			$f[$k]=$i18n[$this->program_name()]['fields'][$k];
		}
		return($f);
	}
	function load_meta($mod,$dir){
		global $std_meta;
		if(file_exists("$dir/meta/$mod.meta.php")){
			require_once("$dir/meta/$mod.meta.php");
			$this->meta= $std_meta[$mod];
		}else{
			//@todo default meta for base class
			$this->meta= array();
			$this->log("$dir/meta/$mod.meta.php not found","WARNING");
		}
		return($this->meta);
	}

	/** 
	 * if the module's i18n has not been loaded yet, load it. 
	 * WARNING= on missing language load default.!!!
	 * @param $mod the module's name
	 * @param $dir THIS IS USED TO LOAD STUFF FROM OTHER PROJECTS; TO ALLOW INTER_PROJECT COMM
	*/
	function load_i18n($mod,$dir='.'){
		global $i18n;
		//on 
		if(!isset($i18n[$mod])){
			$lang_file=$dir.'/i18n/' .std_get_language() . '/' .$mod.'.i18n.php';
			$local_lang_file=$dir.'/i18n/' .std_get_language() . '/' .$mod.'.i18n.php';
			if(!file_exists($lang_file)){
				$lang_file=SHARED_MODULES_DIR.'i18n/'.std_get_language().'/'.$mod.".i18n.php";//FIX6
			}
			if(!file_exists($lang_file)){
				$this->log('no_strings_file:std041'.gp2(array(
					'file'=>$mod,
					'shared'=>$lang_file,
					'local'=>$local_lang_file)),'ERROR');

				$i18n[$mod]=array(
					"nomodel"=>1
				);
			}else{
				require_once($lang_file);
				if(!isset($i18n[$mod])){
					$this->i_error('strings_file_corrupt','std039',array(
						'file'=>$mod,
						'shared'=>$lang_file,
						'local'=>$local_lang_file));
				}
			}
		}else{
			//what to do here?	
		}
		
		
	}
	/**
	 * \todo 291 this is a WEAK method, must a find a better one!
	 * you can re-implement the view parser, to implement special behavior based on special DSLs you contruct from views
	 * @see std::parse_model_info
	 * */
	function parse_view($view){//,$current_record_id
		//FIX FIELD NAME MISSING
		
		if(isset($view['fields'])){//some views don't have fields (like for instance: pie)
			$view['fields']=$this->view_expand($view['fields']);
			foreach($view['fields'] as $k=>$field){
				if(!isset($field['name'])){
					$view['fields'][$k]['name']=$k;
				}
			}
			$view["fields"] = $this->parse_special_values($view["fields"]);
			if($this->enable_auth==1){
				$view["fields"] = $this->parse_auth($view["fields"]);
			}
		}

		#if(array_key_exists('restrict',$view) && $view['restrict']=='@mine'){
		#	$view['restrict']=$this->table . '_' . $this->id . ' = \'' . $current_record_id . '\'';
		#}
		return($view);
	}

	/** \brief will get me a record
	 * @param $id the ID defaults to $_GET[id] if not found
	 *
	 * */
	function find_by_id($id='@none'){
		if($id=='@none'){
			$id=$_GET['id'];
		}
		$id=$this->remove_strange_chars($id);
		$q=$this->q2obj('SELECT * FROM '.$this->get_table_name().' WHERE '.$this->id.' = '.$id);
		if(count($q)==0){
			$this->i_error('no_such_record','std801');
			exit;
		}
		return($q[0]);
	}
	/**
	 * @FIX FIX FIX
	 * \todo 1124 implement find
	 * */
	function find($field,$value){
		if($this->is_foreign_id($this->fields[$field])){

		
		}
	}
 
	/**
	 * i18n: any data inside the i18n array (solves having to add "global $i18n"stuff, which i find quite anoying)
	 * @param $key an \ref i18n_key i18n key
	 * @param $mod a \ref module_name module name
	 *
	 * */
	function i18n($key,$mod=""){
		global $i18n;
		if($mod==""){
			$mod=$this->program_name();
			if($mod=='STD_NO_TABLE'){
				$this->log('SERIOUS ERROR:'.gp2(debug_backtrace()),'ERROR');
			}
		}else{
			$this->load_i18n($mod);
		}

		if(isset($i18n[$mod][$key])){$t=$i18n[$mod][$key];}else{$t=$this->program_name().'.i18n():missing:'.$key;}
		return($t);
	}
	/** 
	 * this will tell you if the key exists
	 * which is useful for diagnosing stuff, I hope
	 * @param $key a key in the i18n array 
	 * */
	function has_i18n_key($key){
		global $i18n;
		return(array_key_exists($key,$i18n[$this->program_name()]));
	}
	
	/** 
	 * @todo retrieves keys from the i18n_std array (please stop using global $i18n_std)
	 * @param $key a key in the global i18n array 
	 * */
	function i18n_std($key){
		global $i18n_std;
		return($i18n_std[$key]);
	}
	/** 
	 * will fetch you the whole i18n array, but its better to use std::i18n() in most cases, and also simpler
	 * */
	function get_i18n_array(){
		global $i18n;
		if(!array_key_exists($this->program_name(),$i18n)){
			$this->log('NO TABLE ARRAY in module:'.$this->program_name().' - '.$this->get_table_name(),'ERROR');
			return(array());
		}
		return($i18n[$this->program_name()]);
	}
	/** \brief fi: field i18n
	 *
	 * @param key the name of the field.
	 * */
	function fi($key){
		global $i18n;
		return($i18n[$this->program_name()]['fields'][$key]);
	}
	/** \brief fh: field help
	 *
	 * @param key the name of the field.
	 *
	 * */
	function fh($key){
		global $i18n;
		return($i18n[$this->program_name()]['fields']["help_".$key]);
	}
	//@}

	/**\todo 258 implement
	 * \brief saves values to the session array
	 * */
	function save_value($input_name,$value){
			
	}

	/** 
	 * logs its calls. (uncomment log line when trace calls on instances needed.
	 * \todo 129372 allow override
	 * \todo 190283 make this unnecesarry on load_file
	 * )
	 *@param $c whether or ont to connect to the database on instantiation, see common::db()
	 * */
	function std($c=0){

		$this->privilege_manager = new privilege_manager($this);
		/*
		$this->alias = new alias_manager($this);
		$this->alias->add('b2l','all_b2l');
		 */
		#$this->log("Module Loaded:".$this->table." public_modules:".implode(',',$this->public_modules),'MODULE');
		if($c==1){
			if(!$this->ping()){
				$this->head();
				$this->i_error('no_db_connection','std001',array('db'=>$this->dbdatabase));
				$this->foot();
				die('');
			}
		}
		$this->db($c);
	}
	/** \defgroup Log Logging Utilities
	 * some aids to development.
	 * */
	//@{

	/**
	 * 
	 * @param $txt the text to be logged
	 * @param $lvl the error level, useful for separating your logs from other, default logs, and setting severity.
	 * \todo add error level filters on VIEW*/
	function log($txt,$lvl='NONE'){
		global $std_error_log;			
		$std_error_log[]=array('lvl'=>$lvl,'txt'=>$txt,'dt'=>microtime());
	}
	/** \brief logs a data structure 
	 * 
	 * displaying the structure using d2() @see d2() 
	 * */	
	function dlog($txt,$lvl='NONE'){
		global $std_error_log;
		$std_error_log[]=array('lvl'=>$lvl,'txt'=>d2_recursive($txt),'dt'=>microtime());
	}
	/** \brief logs the structure using p2() */
	function plog($txt,$lvl='NONE'){
		global $std_error_log;
		$std_error_log[]=array('lvl'=>$lvl,'txt'=>gp2($txt),'dt'=>microtime());
	}
	/*
	 * NEW, OLD
	 * */
	function diff_array($arr1,$arr2){
		$diff=array();
		foreach($arr1 as $k=>$a1){
			if($a1!=$arr2[$k]){
				$diff[$k]=$arr2[$k].' -> '.$a1;
			}
		}
		return($diff);
	}
	/**
	 * gets
	 * field_a=>b,field_c=>d
	 * returns
	 * Field A: b
	 * Field C: d
	 * */
	function nice_array($arr){
		$txt='';
		foreach($arr as $k=>$v){
			$txt.="\n".$this->fi($k).' = '.$v;
		}
		return($txt);
	}
	/**
	 * application logs to DATABASE facility 
	 * do NOT confuse w/ log*() functions, which log to SESSION DEBUG INFO
	 * this stays forever (kindof)
	 * level is optional (and not a number, this is not C ;) )
	 * level hierarchy:
	 *
	 * system
	 * error
	 * app
	 * warning
	 * your_hierarchy_here
	 *
	 * info Record, table level
	 *
	 * USAGE EXAMPLE:
	 *	$this->log_event('INSERT',$this->last_id());
	 * */
	function log_event($info,$record='1',$table='@me',$level=1){
		global $config;
		if($config['enable_logging']==1){
			if($table == '@me'){
				$table = $this->get_table_name();
			}
			if($this->logger == ''){
				$this->logger = $this->load_file('log');
			}
			$this->logger->log_event($table,$record,$info,$level);
		}
	}
	/** \brief log something but once
	 * @see std::log()
	 * very useful inside loops, that can run 100s of times,
	 * but you want the action logged only once
	 *
	 * */
	function log_once($txt,$lvl){
		if(!is_array($GLOBALS['std_logged'])){
		$GLOBALS['std_logged']=array();
		}
		if(!in_array($txt,$GLOBALS['std_logged'])){
			$GLOBALS['std_logged'][$txt]=$txt;
			std::log($txt,$lvl);
		}
	}
	/** 
	 * \brief gets the log's text 
	 * @return the log's text 
	 * @see std::log() */
	function get_log(){
		global $std_error_log;
		include_once(INCLUDE_DIR.'std_tab.php');
		#echo(b2());
		#echo("<hr color=red />");
		#print_r($std_error_log);
		$all=array();
		$all['log']='This will not be displayed on the production server';
		$all['ALL']='';//E_NOTICE
		foreach($std_error_log as $k=>$v){
			$all['ALL'].="\n".'<br/><font color=red><b>'.$v['lvl'].'</b></font>&nbsp; '.$v['txt'];
			if(!isset($all[$v['lvl']])){$all[$v['lvl']]='';}//E_NOTICE
			$all[$v['lvl']].=$v['txt'].'<hr/>';	
		}
		
		$a=new tab($all,'mine');
		return($this->noprint($a->out('100%')));
	}
	//@}


	/** \defgroup link_parsing Link Parsing Utilities
	 * usually, any link that work in this system require 2 parts, a MODULE (mod) and an ACTION (ac)
	 * the usual format to represent these is mod/act, where a slash separates the mod and the act.
	 * however, this format shouldn't be written in stone, which is why I wrote the functions.
	 * 
	 * */
	//@{

	/** \brief Returns "a" when action is "a/b"
		if we ever change the execution mode, 
		I hope this is one of the few places that will need changing.
		
	*/
	function get_mod($action){
		
		#echo("ac.".$action);
		if(strpos($action,"/")===FALSE){
			return($action);
		}else{
			$ac=explode("/",$action);
			return($ac[0]);
		}	
	}

	/**
		Returns "b" when action is "a/b"
		if we ever change the execution mode, 
		I hope this is one of the few places that will need changing.
	*/
	function get_act($action){
		if(strpos($action,"/")===FALSE){
			return("");
		}else{
			$ac=explode("/",$action);
			return($ac[1]);
		}	
	}
	/**
	returns current mod and AC,
	it also helps contruction of already existing mods.
	*/
	function mod_and_ac($mod="@none",$ac='@none'){
		if($mod=='@none' && $ac=='@none'){
			if(isset($_GET["ac"])&&$_GET['ac']!=''){
				if(isset($_GET["mod"])){
					$ac=$_GET["mod"]."/".$_GET["ac"];
				}else{
					//no mod!
					$this->log('ERROR: no mod on:mod_and_ac on '.$mod.'/'.$ac,'ERROR');
				}
			}else{
				if(isset($_GET["mod"])){
					$ac=$_GET["mod"];
				}else{
					$this->log('ERROR: no mod on:mod_and_ac on '.$mod.'/'.$ac,'ERROR');
					//error no mod!
				}
			}
		}else{
			if($ac!=''){
				$ac=$mod."/".$ac;
			}else{
				$ac=$mod;
			}				
		
		}	
		return($ac);
	}
	
	//@}
	
	/**
	 * gets: a, a/b or array(a,b) and returns always array()
	 
	 see 10298
	that means the action is in the form: module/action
	@todo 8000 multiple action to different modules
	workarround: create an action from another module, that redirects
	I mean, how often will this happen?
	 * */
	function normalize_action($action){
		$d=array();
		if(is_array($action)){
			$d=$action;
		}else{	
			$d['label'] = $this->get_i18n_text($action,'form_');
			$d['action'] =$action;
		}
		if(strpos('/',$d['action'])){
			//10298
		}
		return($d);
	}
	/** \defgroup Privilege Privilege Utilities
	 * *some functions to handle privileges and role management
	 * @todo make an object to handle all this stuff?
	 *
	 * */
	//@{

	/** \brief retrieves current role name
	 *
	 * Gets the role name of the current action loking for it in the Session menu array.
	 * @param $ac if nothing is given, it will use the current action, and the current module (how you got there))
	 * */
	function get_role_name($ac='@current'){
		global $mydir;
		if($ac=='@current'){
			$ac=$this->program_name().'/'.$this->current_action;
			//todo 4000 send fix to func
			if($this->current_action=='view'){
				$ac.=':'.$this->current_view;
			}
			$this->log('using default current action:'.$ac.' @get_role_name','PRIV');
		}
		//this looks for 
		if(array_key_exists($ac,$_SESSION[$mydir]["usr"]["_priv"])){
			return($_SESSION[$mydir]["usr"]["_priv"][$ac]["role_name"]);
		}else{
			$e = $this->privilege_manager->find_privilege_matching($ac,'NOT_EXISTS');
			
			if(is_array($e)){
				return($e['role_name']);
			}else{
				//p2($_SESSION[$mydir]["usr"]["_priv"]);
				//p2($ac,'red');
			}
		}
		$this->log("no such role for act:".$ac,'PRIV');
		$this->i_error('no_role','std074',array('ac'=>$ac));

		return("ERROR:Uknown Role");
		
	}

	/** 
	 * @brief returns an array of all the actions which are implemented by the module 
	 * all std actions are removed
	 * app_base actions are not removed
	 * @see util::install_manager
	 *
	*/
	function get_own_actions(){
		$s=new std();
		$parent_ac=$s->get_valid_actions();
		$d3=array();
		foreach($this->get_valid_actions() as $child_ac){
			if(!in_array($child_ac,$parent_ac)){
				$d3[$child_ac]=$child_ac;
			}
		}
		return($d3);
	}
	/** 
	 * \brief an array of valid actions for this module, returned in common::aa format
	 * */

	function get_valid_actions(){
		$i=$this->get_func_list('ac_');
		$acl=strlen('ac_');
		$i2=array();
		foreach($i as $k=>$v){
			$i2[$k]=substr($v,$acl,strlen($v));
		}
		unset($i2[$this->view_handler_function]);
		foreach($this->get_view_list() as $k=>$v){
			$i2['view:'.$v]='view:'.$v;
		}
		return($i2);
	}
		
	/** \brief deletes the current session's stored privilege array,
	 *
	 * useful in situations where you want your privileges revoked and rebuilt, 
	 * without having to login into the system again 
	 * i.e. when you add a privilege to a role (maybe modifying the menu)
	 * \todo 1128 make this work in priv add, etc
	 * */
	function flush_privileges(){
		global $mydir;
		unset($_SESSION[$mydir]['usr']["_privileges_menu"]);
	}
	/** 
	 * this fetches the current logged in user's roles.
	 * */
	function get_roles(){
		global $mydir;
		return($_SESSION[$mydir]['usr']['_roles']);
	}

	
	//@}
	function get_current_url(){
		return(urlencode($_SERVER['REQUEST_URI']));
	}
	/** @defgroup misc Miscelaneous Functions
	 * that defy our best attempts to sort them
	 *
	 * */
	//@{
	/** this goes down in the record*/
	function kid_contents($where_expression){
		return('');
	}
		/** @todo */
	function tab_see_also_links(&$tabs){
		$contents ='';
		if(isset($this->rel['hbm']) && is_array($this->rel['hbm'])){
			foreach($this->rel['hbm'] as $m=>$t){
				$m1=$this->load_file($m);
				if($this->privilege_manager->is_allowed($m.'/all')){
					#dbg $this->log("tab_see_also_links():ADD:".$m,'VIEW');
					$contents.='<li>'.$this->mkl(array('mod'=>$m,'ac'=>'all'),$m1->i18n('table_plural'))."</li>";
				}else{
					#dbg $this->log("tab_see_also_links():NOTADD:".$m,'VIEW');
				}
			}
		}
		if($contents!=''){
			$tabs->add_tab($this->i18n_std('see_also'),"<ul>".$contents."</ul>");
		}
	}	
	function parse_tab_info($tabs){

	}
	function get_add_link($link_options){
		$o = $this->inherit(array(
				'mod'=>$this->program_name(),
				'ac'=>$this->default_create_action,
				'__current_url'=>$this->get_current_url(),
			),$link_options);
		$ret = '';
		if($this->privilege_manager->is_allowed($this->mod_and_ac($this->program_name(),$this->default_create_action)) == 1){
			$ret = $this->make_link($o,$this->i18n('new_table_title'),'action_link kid_add_link');
		}
		return($ret);
	}
	
	/** this will send you back to where-ever you were, however, yuou must NOT output ANYTHING before this function is called
	 * otherwise, everything fucks up
	 * */
	function send_b2l_headers(){
		$link = '?mod='.$this->program_name().'&ac=all_b2l';
		if(isset($_GET['__current_url'])){
			$link = $_GET['__current_url'];
		}

		if(!headers_sent()){
			header('Location: '.$link);
		}else{
			echo('<script>;location.href="'.$link.'";</script>');
			die();
		}
	}
	/**\brief returns a "back to list", when Apropiate.
	 *
	 *
	 * 	and adds the  Privilege, since it must be explicit.
	 * 	\todo 237 viewport ids, and viewport identification
	*/
	function b2l_link(){

		global $i18n,$i18n_std,$mydir;
		//there is a list in the last viewed folder
		if((is_array($_SESSION[$mydir]["usr"]["_search"]) && array_key_exists($this->table,$_SESSION[$mydir]["usr"]["_search"])) || is_array($_SESSION[$mydir]["usr"]["_last_list"])){
			//$this->privilege_manager->ap($this->b2l_default_action);
			return("<br /><br />".$this->make_link(array('mod'=>$this->program_name(),'ac'=>$this->b2l_default_action),$i18n_std["list"]["form_all_b2l"],'b2l_link'));
		}else{
			return("<br /><br />");
		}	
	}


	/** returns a simple array. q2a: query to array
	 * @param $sql an SQL Select statement
	 * usage:
	 * @code
	 * $this->q2a('select name,other_field, etc from table');
	 * @endcode
	 * returns a list of names.
	 *
	 * */
	function q2a($sql){
		$q=$this->q2obj($sql);
		$q1=array();	
		foreach($q as $k=>$v){
			foreach($v as $k1=>$v1){
				$q1[]=$v1;
				break;//just the first one please.
			}
		}
		return($q1);
	}

	/**
	 * gets array(a=1,b=2),array(a=3)
	 * and returns
	 * array(a=3,b=2)
	 *
	 * notice how 'a' is present in both arrays, and the second array's value is preserved
	 * overriding the first.
	 *
	 * its like inheritance, but with arrays
	 *
	 * */
	function inherit($array_original,$array_override){
		foreach($array_override as $k=>$over){
			if(is_array($over) && is_array($array_original[$k])  ){
				$array_original[$k]=$this->inherit($array_original[$k],$over);
			}else{
				$array_original[$k]=$over;
			}
		}
		return($array_original);
	}
	

	/**
	 * useful as hell
	 *
	 * this allows you to get, for instance, a list of field names, 
	 * by doing this:
	 * @code 
	 * $names=sub_array($this->q2obj('select name from table_name'),'name')
	 * @endcode
	 * 
	 * returns 1,2,3 from a((1,22,33),(2,44,55),(3,99,991)
	 * */
	function sub_array($array,$key){
		$s=array();
		foreach($array as $k=>$v){
			$s[]=$v[$key];
		}
		return($s);
	}
	/** this helps to build all kinds of expressions.
	 *
	 *$a=array(array(100,2,3),array(200,2,3))
	 *$b=$this->sub_implode($a,0, ' OR ') // 100 OR 200
	 * @param $array a bi-dimensional array
	 * @param $key a key inside the second level of the array (field name, etc)
	 * @param $char the string that joins all together
	 *
	 * */
	function sub_implode($array,$key,$char){
		$s=array();
		foreach($array as $k=>$v){
			$s[]=$v[$key];
		}
		return(implode($char,$s));
	}

	
	/** 
	 * retrieves the Title, using AC & MOD information, from the current user's privilege list 
	 * (session.usr._priv) 
	 * @param $final the title you want (I know, its kind of obnoxious to make a funciton that returns whet you give to it, but it was necessary)
	 * */
	function get_title($final=''){
		global $mydir;
		$ac=$this->mod_and_ac();
		#at this point, ac is a/b or just a
	
		$ac1=$this->get_mod($ac);
		$txt='';
		$txt='';
		#p2($_SESSION[$mydir]['usr']['_priv']);

		if(isset($_SESSION[$mydir]['usr']['_priv']) && is_array($_SESSION[$mydir]['usr']['_priv'])){
			foreach($_SESSION[$mydir]['usr']['_priv'] as $p){
				$regex = "/^".str_replace("*",".*",str_replace("/","\/",$p["action"]))."$/";
				##echo("<br/>REGEX:$regex AC=$ac macth=".(int)preg_match($regex,$ac));
				if(preg_match($regex,$ac)){
					$txt = $p["privilege_name"].' / '.$p["role_name"]; //"FOUND:".$regex;
					break;
				}
			}
		}

		#OBSOLETE:
		#if(isset($ac,$_SESSION[$mydir]['usr']['_priv'][$ac])){
		#	$rec=$_SESSION[$mydir]['usr']['_priv'][$ac];
		#	$txt=$rec["privilege_name"].' / '.$rec["role_name"];
		#}
		#we don't care that much about which role called it, right?

		$final=$txt.' / '.$final.'@'.$_SERVER['HTTP_HOST'].' ('.$this->version.')';
		return($final);
	}



	//@}
	/** @defgroup layout Layout
	 * Layout functions, that determine how the application looks.
	 * execution order is:
	 - 1.head()
	 - 1.1 before_anything
	 - 2.[your action handler] i.e. ac_mine() (you are the one responsible for calling std::menu())
	 - 1.1 after_anything
	 - 3.foot()
	 *
	 * such scheme allows you to remove the menu from certain views (where you want , for instance
	 * all the screen for yourself)
	 *
	 * to disable std::head() and std::foot(), use:
	 * @code 
	 * $_GET[__output_type] != 'HTML'
	 * @endcode
	 * or 
	 * @code 
	 * $this->disable_header('some_action');
	 * @endcode
	 *
	 * skins are a way of specifying layout, in a simpler maner, check the skins directory for more information
	 * 
	 * */
	//@{
	/** \brief where is the icon?
	 *
	 *
	 * override @ _base
	 * 
	 * icon is found in shared_media, or declared in config.icon
	 * (see @ref config Config)
	 *
	 * */
	function get_icon(){
		global $config;
		//./media/icon.ico
		if(!array_key_exists('icon',$config)){
			return(MEDIA_DIR.'icon.ico');
		}else{
			return($config['icon']);
		}
	}

	/** 
	 * this works with the skins ./dir 
	 * @see std::get_skin_array
	 * */
	function load_skin(){
		global $config,$std_skin;
		if($config['skins_enabled']==1){
			include_once($this->get_skin_folder().'skin.php');
		}
	}
	/** 
	 * @see std::load_skin
	 * */
	function get_skin_array(){
		global $std_skin,$config;
		if($config['skins_enabled']==1){
			$this->load_skin();
			return($std_skin[$config['skin_name']]);
		}
		return(array());
	}
	/**@todo std::get_header() please implement saomething cool here, like for instance, a navigation table, a super cool super search thing, etc*/
	function get_header(){
		#return("<div style='width:100%;background-color:black'>nice</div>");
		return("");
	}
	/** 
	 * \brief Prints HTML prelude, css,js, etc
	 * if you override this, you can set your own headers.
	 * if you want no headers (because you need to output XML, a PNG etc), use 
	 * @code
	 * $_GET[__output_type] != 'HTML'
	 * @endcode 
	 *
	 * @param $title the title of the page 
	 * @returns nothing
	 * */
	function head($title="Untitled Section"){
		global $config, $mydir;

		if(!array_key_exists('__output_type',$_GET)){
			$_GET['__output_type']='HTML';
		}
		//disable headers output based on this.disable_headers var
	//	echo($this->current_action);
		if(array_key_exists($this->current_action,$this->disable_headers)){
			//echo('disabled!');
			return("");
		}
        #p2(debug_backtrace());
        
		$title=$this->get_title($title);
		if($_GET['__output_type']=='HTML'){

			$style_file_location=MEDIA_DIR.'style.css';
			if(array_key_exists('style',$config)){
				$style_file_location=$config['style'];
			}
			$template=$this->get_template_contents('main');

			$e  = preg_split('/(\[#_menu\]|\[#_page\])/',$template);

			$a=array(
				'title'=>$title,
				'header'=>$this->get_header(),
				'icon'=>"<link rel=\"shorcut icon\" href='".$this->get_icon()."' />",
				'stylesheet'=>"<link rel=stylesheet tyle='text/css' href='".$style_file_location."' />",
				'MEDIA_DIR'=>MEDIA_DIR,
				'user_stylesheet'=>"<link rel=stylesheet tyle='text/css' href='./media/user.css' />",
				'module_stylesheet'=>"<link rel=stylesheet tyle='text/css' href='./media/".$this->program_name().".css' />",
				'script'=>
					$this->get_jsc('js').
					$this->get_jsc('i18n/'.std_get_language()).
					"<script>;if(window.top){window.top.document.title=document.title;};</script>" //fix framed document title
					,
				'body_before'=>$this->body_before,
				'background_color'=>'#FFFFFF',
				'text_color'=>'#000000',
				'title_color'=>'#000000',
				'body_before'=>$this->body_before,
				'is_inside'=>$_SESSION[$mydir]["inside"],
				'ssid'=>ssid(),
				'ssname'=>ssname(),
			);
			if($config['skins_enabled']==1){
				$s = $this->get_skin_array();
				foreach($s as $sk=>$sv){
					$a[$sk]=$sv;
				}
				$a['skin_stylesheet']="<link rel=stylesheet tyle='text/css' href='?mod=skin&ac=preproccessor&table=".$this->program_name()."&__output_type=CSS' />";
			}else{
				$a['skin_stylesheet']="";
			}
			echo($this->fmt($e[0],$a,'_'));
			
			//TO DEBUG HEADER ERRORS MADE BY disable_headers, use this line:
			//echo('head is print:'.$this->current_action);if($_GET['DEBUG']!=1){die(1);}

			$this->menu_str=$this->fmt($e[1],$a,'_');
			$this->end_str=$this->fmt($e[2],$a,'_');

		}elseif($_GET['__output_type']=='CSS'){
			header('Content-Type: text/css');
		}elseif($_GET['__output_type']=='JSON'){
			//echo nothing.
		}
	}

	/**\brief Print Footers
	 * this prints the Footers, and displays debugging information, 
	 * about the database, sql queries, and the ERROR LOG. @see std::log
	 * it also prints how long it took the script to complete, for profiling.
	 * @see log
	 * @see db::trace()
	 * @see $timestart
	 * WARNING: this function is called not from the module, but from the base, where no $this->table or any of that stuff exists.
	 *
	 * */

	function foot(){
		
		global $std_error_log,$timestart,$mydir,$std_usr_data,$common_count;
		if(!array_key_exists('__output_type',$_GET)){
			$_GET['__output_type']='HTML';
		}
		if(array_key_exists($this->current_action,$this->disable_headers)){
			//echo('disabled!');
			return("");
		}

		if($_GET['__output_type']=='HTML'){
			echo($this->end_str);

			if(DEBUG){
				echo("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
				echo("<!--PAGE DEBUG INFO START -->\n<div style='display:block' id='debug_info'>");
				#display database information.
				$timeend = microtime();
				$diff = number_format(((substr($timeend,0,9)) + (substr($timeend,-10)) - (substr($timestart,0,9)) - (substr($timestart,-10))),4);
				$this->shadow_start();
				$this->log("Script generation took $diff s<br /><br />",'PROFILE');
				//echo("<tr><td colspan=2>");
				//p2($_SESSION,'blue');
				//	p2(std::get_permissions_list(),'red');
				//
				//
				//$this->table.'/view:'.$this->current_view
				//$this->log("USER ALLOWED TO DO THIS:".std::in_permissions_list(),7);
				//echo("</td></tr>");

				$this->dlog($_GET,'GET');
				$this->dlog($_POST,'POST');
				
				$this->dlog('common() count is:'.$common_count,'PROFILE');
				$this->log($this->get_trace(),'SQL');
				//$this->dlog($_SESSION[$mydir],'SESSION');
				if(isset($_SESSION[$mydir]['usr']['field_presets'])){
					$this->plog($_SESSION[$mydir]['usr']['field_presets']);
				}
	//			echo("<br />USER DATA:<br>");
	//			p2($std_usr_data);

				echo($this->get_log());
				$this->shadow_end();
				echo("</div>");
				
			}

		}elseif($_GET['__output_type']=='JSON'){
			//do nothing
		}
	}
	/**
	 * \brief displays the menu with all the possible actions for the current user.
	 * to disable it's output, use :
	 * @code
	 * $this->show_menu=0;
	 * @endcode
	 * useful when you need to calls function, that calls std::menu() (i.e. ac_view()),
	 * but have already shown the menu before.
	 *
	 * these actions are saved in the $_SESSION array, so that the database is only accessed once.
	 * if you change anything in the privilege table, or the role2priv table, that affect current users,
	 * be advised that those users must re-login for cganges to take effect.
	 *
	 * if you something like a guest menu, override the default_login_module, and implement wathever you wish convenient, see also std::$is_guest
	 * 	Override when necesary.
	 * 	saves the  menu in Session, so its not always recalculated.
	 * 	the menu's logo is at /config.php:$application_logo
	 * */
	function menu(){

		global $i18n_std,$config,$mydir,$main;
		$this->log('menu()','PRIV');
		$dx='';
		if($this->is_shared_module_flag==1 &&isset($main) && $this->show_menu==1 && $config["menu_overrriden"]==1){
			$this->log(get_class($this).' does not display the menu, $main does. (MENU IS SHARED)','PRIV');
			$main->menu();
			return("");
			
		}else{
		
		}
		$all =$this->privilege_manager->get_menu_options();
		$dta=array();
		$dta[]=array('role_name'=>'','link'=>
			"<span class=standard_text>".
			$i18n_std["menu"]["logged_in_as"].ssname()
			."</span>"
		);
					
		$is_guest=0;
		if(count($all)==0 || !is_array($all)){
			$is_guest=1;
			/** \todo do something about it. (user being Guest) */
			#$this->i_error("unable_to_fetch_privileges",'std100');
			#return(0);
		}else{

			if($this->show_menu==1){

			//p2($all,'green');
			foreach($all as $k=>$p){
				$mod9=$this->get_mod($p['action']);
				$ac9=$this->get_act($p['action']);

				//this sections makes ac=='' to produce nicer links
				$ac2=str_replace('*','',$ac9);
				$l2=array();
				$l2['mod']=$mod9;
				if($ac2 != ''){
					$l2['ac']=$ac2;
				}
				$dta[]=array(
					'role_name'=>$p['role_name'],
					'link'=>$this->make_link($l2, $p['privilege_name'], 'menu_link')
				);
			}

				/*
				$this->shadow(
					
					$this->li($this->group_by2($dta,'role_name','link'))
					,$this->shadow_config['menu']);
				echo("</div>");
				 */

				$template=$this->group_by2($dta,'role_name','link');

				ksort($template);
				$template['<!-- LOGOUT_LINK -->']=array($this->make_link(array('logout'=>1),$i18n_std['logout'],' logout_link menu_link'));
				$logo=$this->get_logo();
				/*
				foreach($tdata as $role_name=>$items){
					foreach($items as $item){
						//$item;
					}
				}
				*/

				if(!array_key_exists('__output_type',$_GET)){
					$_GET['__output_type']='HTML';
				}
				if($_GET['__output_type']=='HTML'){

					#p2($template);
					$f = $this->get_skin_folder().'menu.php';
					if(file_exists($f)){
						include($f);
					}else{
						include(SHARED_MODULES_DIR.'templates/menu.php');
					}
				}
				echo($this->menu_str);
			}
		}	
	}
	/** 
	 * returns HTML necessary to display the Logo.
	 * */
	function get_logo(){
		global $config,$std_env;
		/// dbg echo('std env web is: '.$std_env['current_web_directory']);
		return("<div align=center>".$this->make_link(array(),"<img border=0 class=app_logo src='".$std_env['current_web_directory'].$config["application_logo"]."' />")."</div>");
	}
	//@}

	/** @defgroup ar Active record
	 *
	 * */
	//@{	
	/**
	 * fetch all records from this table.
	 * @param $sql an SQL where clause
	 * */
	function find_all($sql=''){
		if($sql!=''){
			$sql=' WHERE '.$sql;
		}
		return($this->q2obj('SELECT * FROM '.$this->get_table_name().$sql));
	}
	//@}

	/** 
	 * \todo 232 _id2, _id3
	 * searches for _id at the end of a a string
	 * @param $field the field name
	 * */
	function is_id($field){
		return(preg_match('/(_)?id$/i',$field));
	}		
	/** 
	 * \todo 232
	 * searches for _id at the end of a a string
	 * @param $field the field name
	 * */
	function is_foreign_id($field){
		return(preg_match('/(_)?id$/i',$field) && ($this->id2mod($field)!=FALSE));
	}		
	/** \brief retrieves the function list, using a given filter
	 * @param $filter the beginning of the function name.
	 * @param $mode mode=1 means no filter included
	 * some reflection
	 * */
	function get_func_list($filter='ac_',$mode=0){
		$len = strlen($filter);
		$ff=array(
			0=>create_function('$a','return($a);'),
			1=>create_function('$a','return(substr($a,'.strlen($filter).'));'),
			);
		$f = $ff[$mode];

		return(
			$this->aa(
				array_map($f,
					array_filter(
						get_class_methods($this),
						create_function('$a','return(preg_match("/^'.$filter.'/",$a));')
					)
				)
			)
		);
	}
	function resolve_title(){
		global $i18n;
		//TODO
		//connect 
		//new with new
		//list_all with all
		//etc with etc
		//view:xx with xx

		return($i18n['apptitle']);
	}
	function get_mods(){
		return($this->aa(array_map(create_function('$x','return(basename($x,".controller.php"));'),$this->get_local_modules())));
	}
	/** 
	 * 	@brief This, is where module excecution starts.
		
		\todo 3001 try to find a way not to load modules twice, 
		when so requested, and reuse the already loaded ones.???
		\todo 3002 remove odd characters like pipe, .. etc from mod name.
		This runs always as : std_base, no table context or current module is available at this point yet.
		this might toss \ref error "error std003"

		WARNING:
		post.mod overwrites get.mod
		post.ac overwrites get.ac

	 */
	function load_current_module(){
		global $i18n,$i18n_std,$mydir;
		
		#$this->log('std::load_current_module():: redirect:'.$this->is_redirect.' now im trying to load something:'.d2_recursive($_GET),'PRIV');
		if(array_key_exists('mod',$_POST)){
			$_GET['mod']=$_POST['mod'];
		}
		if(!isset($_GET['mod']) || !(is_array($_GET)) || (!array_key_exists('mod',$_GET) || $_GET['mod']=="")){
			$_GET['mod']=$this->default_module;	/*default_module*/
			$this->privilege_manager->ap_login();
			$this->log('load_current_module:: mod.get does not exists, prepare for login procedures','PRIV');
		}

		//echo("you just loaded:".$_GET['mod']);
		$module=$this->load_file($_GET['mod']);
		if($module==0){
			//std::i_error('unable_to_continue','std003');
			return(0);
		}
		//echo("<h1> Untouched GET</h1>");p2($_GET);echo("<h1> Untouched POST</h1>");p2($POST);
		if(array_key_exists('ac',$_POST)){ $_GET['ac']=$_POST['ac'];}
		if(array_key_exists('_submit',$_POST)){	$_GET['_submit']=$_POST['_submit'];}
		if(array_key_exists('submit',$_POST)){	$_GET['submit']=$_POST['submit'];}
		//echo("<h1> GET</h1>");p2($_GET);echo("<h1> POST</h1>");p2($POST);

		if(!array_key_exists('ac',$_GET) || $_GET['ac']==""){
			#no ac, lets check for submit.
			$this->log('load_current_module:: get.ac doesnt exist, looking for _submit instead','MODULE');

			if(array_key_exists('_submit',$_GET)){
				#look for of the _submit array that match what the user clicked (get.submit)
				$founs=0;
				foreach($_GET["_submit"] as $k2=>$v2){
					if($_GET["submit"]==$v2){
						$action="ac_".$k2;
						#GET is emulated, so everyone thinks that all is good in the world, 
						#and never see or have to deal with this litle hack directly
						$_GET["ac"]=$k2;
						++$found;
						break;		
					}
				}
				if(!$found){
					$this->i_error('submitted_action_not_found','std070');
				}
			}else{
				#if we dont find it, well use the mod's default.
				$action="ac_".$module->default_action;
				
				$this->log('USING :'.$action,'MODULE');
					
			}

		}else{
			$this->log('load_current_module:: get.ac DOES exist. _submit is ignored','MODULE');
			
			#action comes from GET.
			$action='ac_'.$_GET['ac'];
		}

		$action2=explode(":",$action);
		if(count($action2)==1){
			$real_action=$action;
			$module->current_view='none';
		}else{
			$real_action=$action2[0];
			$module->current_view=$action2[1];
		}
		$this->log('load_current_module:: real action:'.$real_action.' view (if aplicable):'.$module->current_view,'MODULE');

		#GETS delete from ac_delete
		#wtf!
		$module->current_action=substr($real_action,strlen('ac_'),strlen($real_action));

		//echo("Context = ".$module->program_name());
		$old_context = $module->program_name();
		/*p2($_GET);p2($_POST);die();*/
		 
		$module->name=$_GET['mod'];
		$new_context = $module->name;
		if($old_context !=$new_context){
			//here we kinda changed the mod's name in a wrong way, so ill put it back to what it was
			//I hope this won't cause any trouble later, but it might
		}
		
		/*
		if(isset($_POST['uri'])){
			$this->log_event('context='.$_GET['mod'].' user ' . ssname() . ' was redirected to ' . $_POST['uri'],'-1','usr','0');
			header('Location: '.$_POST['uri'].'&__is_redirect=1');
			die();
		}
		 */

		
		if(!in_array($real_action,get_class_methods($module))){
			$this->head();
			$this->i_error('no_such_action','std071',array('ac'=>$real_action,'mod'=>$module->program_name()));
			$this->foot();
		}else{
			#if the user's not authorized, then he can't go trough.
			#
			$this->log('load_current_module:: preparing to autenticate:'.gp2($module->public_modules),'PRIV');
		
			if((array_key_exists($mydir,$_SESSION) && 			//the SESSION thing could be broken
				array_key_exists('usr',$_SESSION[$mydir]) && 
				array_key_exists('_priv_mods',$_SESSION[$mydir]['usr']) && 
				!in_array($module->name,$_SESSION[$mydir]['usr']['_priv_mods'])
			) && (!in_array($module->name,$this->public_modules))){		//public module check is important, due to CSS skin support
					$this->std_unauthorized_access($module->program_name());
			
			}else{
				$this->log('load_current_module:: ok, the user\'s got the mod, now let\'s see if he\'s got the act...','PRIV');
				
				$m=$module->mod_and_ac();
				
				$this->log("WELCOME GUEST:testing AC:'$action' m: $m",'PRIV');
			//	echo("TESTING=".$action);
				if(in_array($action,$module->restrictions["allow"])){
					$allowed=1;
					#since there IS probably no role for this, ill just add it manually.
					$this->log("USER IS GUEST m:$m and I am running:".$this->table.' TEXT KEY:'.$module->get_act($m)." FROM: ".$m,'PRIV');
					//this is being run in base.
					$module->privilege_manager->add_privilege(array(
						'action'=>$m,
						'role_name'=>$i18n_std["roles"]['guest'],
						'privilege_name'=>
								$module->i18n('table_plural').
								" : ".
								$module->get_i18n_text($module->get_act($m))
					));
				}else{
					$allowed=0;
				}

				
				$module->record=new act_base($_GET['mod']);

				$this->log('load_current_module:: is allowed:'.($allowed || $module->privilege_manager->is_allowed($m)),'PRIV');

				//echo('we want to know if this user is ALLOWED:'.(int)$module->privilege_manager->is_allowed($m));
				
				if($allowed || $module->privilege_manager->is_allowed($m)){
					//AHA!
					$module->head($this->resolve_title());
					$module->before_anything();
					$module->fields = $module->parse_sqlvalues($module->fields);
					$module->$real_action();
					$module->after_anything();
					$module->foot();

				}else{
					$this->log('load_current_module:: back to square 1: inside'.$_SESSION[$mydir]["inside"],'PRIV');

					if($_SESSION[$mydir]["inside"]==1 && is_array($_SESSION[$mydir]["usr"]["_priv"])){
						$this->head();
						$this->i_error('no_auth_ac','std073',array('ac'=>$m));
						$this->log("$m not in:<br />".implode(",<br />",array_keys($_SESSION[$mydir]["usr"]["_priv"]))." nor in: ".implode(',',$this->restrictions["allow"]),'ERROR');
						$this->foot();
					}else{
						//this happens when you are not "inside"
						//first time system entry, means we should provide a login screen.
						
						$this->std_unauthorized_access($module->program_name());
					}	
				}	
			}
		}	
		

	}//end current_module

	/** @defgroup events_system Events System
	 * the events system, allows you to specify behavior from the database itself, using a table called event,
	 * see core/shared/controller/event.controller.php for more information
	 *
	 * there are 2 types of events, BEFORE events and AFTER events, if you wish to re.implement this syetm
	 * all you have to do is declare before_anything and after_anything so they fit your needs.
	 *
	 *
	 * */
	//@{	
	/** 
	 * takes in a list of fields, and executes SQL 
	 * sql must say AS value for the field desired for it to work
	 * 
	 * @todo scalar SELECT
	 *
	 * */
	function parse_sqlvalues($fields){
		foreach($fields as $k=>$f){
			if(isset($f["sqlvalue"])){
				$sql_result = $this->q2obj($f["sqlvalue"]);
				if(count($sql_result)==0){
					$this->log("ERROR: NO ROWS FOR :".$f["sqlvalue"],'EVENT');
				}elseif(count($sql_result)>1){
					$this->log("ERROR: MORE THAN ONE ROW RETURNED ON:".$f["sqlvalue"].d2_recursive($sql_result),'EVENT');
				}else{
					$cn = 'NONE';
					$found = 0;
					foreach($sql_result as $row){
						foreach($row as $cell_name=>$cell){
							$cn = $cell_name;
							$found = 1;
							break;
						}
					}
					if($found == 0){
						$this->log("NO ROWS ?? WTF".$f["sqlvalue"].d2_recursive($sql_result),'EVENT');
					}
					$this->log("REPLACE:".$f["value"].' WITH: '.$f["sqlvalue"].d2_recursive($sql_result),'EVENT');

					$fields[$k]['value'] = $sql_result[0][$cn];
					#p2($sql_result);echo("CN IS=$cn");
					unset($f["sqlvalue"]);

				}
			}
		}
		return($fields);
	}
	/** 
	 * this will tell you if events are enabled, check the config key enable_events in YOUR_APP/config/default.config.php
	 *
	 * */
	function events_enabled(){
		global $config;
		return(isset($config['enable_events']) && ($config['enable_events']==1));
	}
	function before_anything(){
		if($this->events_enabled()){
			$events = $this->load_file('event');
			$events->run_events('before',$this->program_name(),$this->current_action,$this);
		}
	}
	function after_anything(){
		if($this->events_enabled()){
			$events = $this->load_file('event');
			$events->run_events('after',$this->program_name(),$this->current_action,$this);
		}
	}
	//@}
	/** @todo 1928374982 make a new login screen, so users can get there, if they know the password (BROKEN)
	 */

	function std_unauthorized_access($program_name){
		global $mydir;
		$this->enable_header($this->current_action);
		$this->head();
		$this->i_error("no_auth_mod",'std072',array('program_name'=>$program_name));
		if(is_array($_SESSION[$mydir]['usr']['_priv_mods'])){
			$mods=implode(",",$_SESSION[$mydir]['usr']['_priv_mods']);
		}else{
			$mods='NO MODS';
		}
		$this->log($program_name." not in ".$mods,'PRIV');
		$this->foot();
		die();
						/*
						if($_GET['__is_redirect']!=1){
							$this->std_validate_user();
						}
						if(!isset($_POST['uri'])){
							$this->std_show_login(array('uri'=>$_SERVER['REQUEST_URI']));
						}else{
							//wtf?
							$this->std_validate_user();
						}
						 */

		/*
		 *
		 *						$this->std_show_login(array('uri'=>$_SERVER['REQUEST_URI']));

		 *
		echo('<h1> please login to access that action:'.$_SERVER['REQUEST_URI'].'</h1>');
		$this->privilege_manager->ap_login();
		$this->std_show_login(array('uri'=>$_SERVER['REQUEST_URI']));
		 */
		
	}
	/**
	 * @param $options array: keys: uri
	 *
	 * */
	function std_show_login($options=array()){
		echo('<h1>show login()</h1>'.b2());
		$this->head();
		$mm=$this->load_file($this->login_module);
		if(isset($options['uri'])){
			$mm->login_redirect=1;
			$mm->redirect_uri=$options['uri'];
		}
		$mm->ac_login();
		$this->foot();
		die();
	}
	/**
	 * this will test for valid users, using the USR module
	 * @see usr_model::validate_user()
	 * */
	function std_validate_user(){
		//echo('<h1>show login()</h1>');
		$mm=$this->load_file($this->login_module);
		$this->head();
		$mm->validate_user();		
		die();
	}

	/**
	 * @ingroup parser
	 * gets b from a:b
	 * this function exists, so that the parser is not tied to this format
	 * altough making the format change is somewhat unrealistinc, and the view:xxx format has been deprecated in favor 
	 * of all* functions that call the views, this was done so that the privilege system would not be broken, and to allow
	 * a future and better implementation of std_unauthorized_access()
	 * @see std::std_unauthorized_access
	 *
	 * */
	function get_view_name($action_name){
		$f=explode(':',$action_name);
		return($f[1]);
	}
	/**
	 * \brief loads a view into the in-memory loaded list
	 *
	 * @param $view_name the name of the view
	 * @param $module_name the name of the module. if nothing is provided, $this table is used.
	 * @returns 0 on faluire or the view object on success.
	 *
	 * @code
	 * if(!$view_object=$this->load_single_view('my_view')){
	 * 	$this->error('not available');
	 * }
	 * @endcode
	 * */
	function load_single_view($view_name,$module_name='@me'){
		global $std_views;
		if($module_name=='@me'){
			$module_name=$this->program_name();
		}
		

		if(!array_key_exists($view_name,$std_views[$module_name]) ){
			$fn = $this->fetch_any_of(array(
				'./view/'.$module_name.'/'.$view_name.'.view.php',
				SHARED_MODULES_DIR.'/view/'.$module_name.'/'.$view_name.'.view.php',
			));
			if($fn){
				include($fn);
				$this->log('load_single_view():loading:'.$module_name.' /'.$view_name.' from '.$fn,'VIEW');
				
			}else{
				//not found
				$this->log('load_single_view():cant find view:'.$module_name.' /'.$view_name.' from '.$fn,'VIEW');
				return(0);
			}
		}else{
			$this->log('load_single_view():using cached view:'.$module_name.' /'.$view_name.' from '.$fn,'VIEW');
			//already loaded, using memory
			return($std_views[$module_name][$view_name]);
		}
		#who am I?
		#$std_views[$module_name][$view_name]=$this->parse_view($std_views[$module_name][$view_name]);
		
		return($std_views[$module_name][$view_name]);
	}

	/**\brief loads a view, that is, it gets a view from a already loaded view list, (std_views)
	 * 
	 * this will add the view_name to the view array before returning it, which is important because we neeed to
	 * know which view is it before we use the template system.
	 * @param $module_name the name of the module (for the current module, use $this->table)
	 * @param $view_name the name of the view, like "list_all", or "list_custom", etc.
	 * @returns 0 on faluire, or a struct with the view on success.
	 *
	 * */
	function load_view($module_name,$view_name){
		global $std_views;
		std::log('load_view loading: mod:'.$module_name." view:".$view_name,"VIEW");
		if($view_name==''){
			std::log("View name is empty",'ERROR');
			return(array());
		}
		$this->load_single_view($view_name,$module_name);

		if(array_key_exists($module_name,$std_views) && array_key_exists($view_name,$std_views[$module_name])){
			$view=$std_views[$module_name][$view_name];
			$view['view_name']=$view_name;
			return($view);
		}else{
			#there is no view, lets see if its a shared one.
			if(!array_key_exists($view_name,$std_views["std"])){
				return(array());
			}else{
				#its a Shared View(TM) !
				$view=$std_views['std'][$view_name];
				$view['view_name']=$view_name;
				return($view);
			}	
		}

		std::log('loading:'.$view_name,'VIEW');
		return(array());
	}
	/**
	 * @param $privilege is in the form module/privilege 
	 * */
	function in_permissions_list($privilege){
		$mod=std::get_mod($privilege);
		return(array_key_exists($privilege,$this->get_permissions_list($mod)));
	}
	/**\brief gets the permissions for all the views, and all the view actions.
	 * \todo 1231232 instead of all, .* (regexp) (slower, but cooler)
	 * \todo 1231231 where can I use that? submods / * ??
	 *
	 * @param $module (optional) the name of the module, when you want *ALL* the modules the user has access to, use the keyword __all.
	 * */
	function get_permissions_list($module='__all'){
		global $mydir;
		$d=array();
	//	p2($_SESSION);
		foreach($_SESSION[$mydir]['usr']['_priv'] as $k=>$v){

			$mod=std::get_mod($k);
			if($module==$mod ||$module=='__all'){
				##std::log('mod:'.$mod,7);
				if(strstr($k,'view:')){//I'ts a view!
					
					///\todo if not loaded
					///\todo, WE KNOW WERE YOU COME FROM, go aback to list is possible!!!

					std::load_module_views($mod);
					$a=std::load_view($mod,std::get_view_name($k));

			//		p2($s,'green');
					$p=array_merge($a['actions'],$a['side_actions'],$a['down_actions']);

					foreach($p as $k1=>$v1){
						$privilege_name=$mod.'/'.$v1;	
						$d[$privilege_name]=$privilege_name;
					}
				}
			}	
		}//for

		//_priv
		$d['usr/view:list_all']='usr/view:list_all';
		
		return($d);
	}

	/** 
	 * \todo 280 if not exist, trow runtime exception,and be done with it
	 * this is like a DLL!
	 * @see std::load_external
	 */
	function gc($fn,$args=array()){
		$d=get_defined_functions();
		$fn2='std_'.$fn;
		if(!in_array($fn2,$d['user'])){
			$this->load_external($fn);
		}
		return($fn2($this,$args));
	}
	/** 
	 * so these funcions get loaded on runtime, on request
	 * kinda like dlls, but nicer.
	 * @see std::gc()
	 * alias for testme 
	 sample usage
	 @code
	 $this->log($this->testme(1,2,3,4,5),'TEST');
	 @endcode
	 * */
	
	function ac_load_csv(){$s=func_get_args();return($this->gc('ac_load_csv',$s));}
	function ac_all_load_from_excel(){$s=func_get_args();return($this->gc('ac_all_load_from_excel',$s));}
	function testme(){$s=func_get_args();return($this->gc('testme',$s));}
	function foreign_select(){$s=func_get_args();return($this->gc('foreign_select',$s));}
	function field_make_foreign(){$s=func_get_args();return($this->gc('field_make_foreign',$s));}
	function create_table(){$s=func_get_args();return($this->gc('create_table',$s));}
	function healthy(){$s=func_get_args();return($this->gc('healthy',$s));}
	function get_ed(){$s=func_get_args();return($this->gc('get_ed',$s));}
	function get_kids(){$s=func_get_args();return($this->gc('get_kids',$s));}
	function get_view_contents(){$s=func_get_args();return($this->gc('get_view_contents',$s));}
	function parse_search_string(){$s=func_get_args();return($this->gc('parse_search_string',$s));}
	function tree_get_parent_field(){$s=func_get_args();return($this->gc('tree_get_parent_field',$s));}
	function ac_all_xml_export(){$s=func_get_args();return($this->gc('all_xml_export',$s));}
	function parse_auth(){$s=func_get_args();return($this->gc('parse_auth',$s));}

	/** reduce_fs reduce foreign select */
	function reduce_fs($data,$fs,$fields){
		$q2 = array();
		foreach($data as $k=>$row){
			foreach($fields as $field_name=>$field){
				$q2[$k][$field_name] = $row[$fs['qfields'][$field_name]['q']];
			}
		}
		return($q2);
	}
	/** \brief removes items on $exclude_fields from $fields and returns $fields.
	 * this is useful when you want to use syntaxes that use : all but this one, 
	 * instead of specifying all the fields
	 * */
	function exclude_fields($fields,$exclude_fields){
		$fields=$this->view_expand($fields);
		$f=array();
		foreach($fields as $k=>$field){
			if(!in_array($k,$exclude_fields)){
				$f[$k]=$field;
			}
		}
		return($f);
	}
	/**
	 * @see get_ie8n_text()
	 * this simplifies the headers() proccess.
	 *
	 * */
	
	function get_i18n_list($fields='all'){
		$h=array();
		$fields=$this->view_expand($fields);
		foreach($fields as $k=>$field){
				$h[$k]=$this->fi($k);
		}
		return($h);
	}
	/*
	 * like common::table() but with headers repeated
	 * It's outout ressemples that of the \G modifier 
	 * in mysql console mode (try it out: 
	 * @code
	 * select * from table \G 
	 * @endcode
	 * (see the use of \G instead of ; ))
	 * @see common::table() 
	 * */
	function g_table($data,$headers,$options){
		//p2($options);
		$out="<!--g_table start-->\n".'<table border=0 cellspacing=0 cellpadding=10 width=100%>';
		$out.="\n".'<tr><td colspan=2><h2 class="form_title standard_title '. $options['style'] .'_title ">'. $options['title'] .'</h2></td></tr>';//simple separator
		//p2($data);
		foreach($data as $k=>$rec){
			$out2="\n".'<table cellspacing="'. $options['cellspacing'] .'" cellpadding="'. $options['cellpadding'] .'" border="'. $options['border'] .'" class="'. $options['style'] .'_table">';
			foreach($rec as $k1=>$field){
				$out2.="\n".'<tr><td class="'. $options['style'] .'_left">'.$headers[$k1].':'.'</td>';
				$out2.="<td class=\"". $options['style'] .'_right">'.$field.'</td></tr>';
			}
			$out2.="\n".'</table>';
			$out.="\n".'<tr><td colspan=2>';
			if(isset($options['shadow']) && $options['shadow'] == 0){
				$out.="\n".$out2;
			}else{
				$out.="\n".$this->get_shadow($out2);
			}
			$out.="\n".'</td></tr>';
		}
		$out.="\n".'</table><!--g_table end-->';
		return($out);
	}
	/** @brief output the content of dsr() (display simple record)
	 * see @dsr()
	 * 
	 * */
	function e_dsr($fields='all',$restrict=' 1=1 ',$exclude_fields=array(),$title='table_plural',$filter='none'){
		$this->shadow($this->dsr($fields,$restrict,$exclude_fields,$title,$filter),'shadow','center');
	}

	/**\brief DSR display simple records
	 *
	 * style:
	 - _table
	 - _tr
	 - _left
	 - _right
	 - _title
	 *
	 * @param $fields a field structure
	 * @see _fields_structure
	 * @param $restrict an SQL where clause
	 * @param $exclude_fields fields to be removed from the final output (good with $fields=all)
	 * @param $filter a filter name /filter array, @see std::filter_trough()
	 *
	 * */
	function dsr($fields='all',$restrict=' 1=1 ',$exclude_fields=array(),$title='table_plural',$filter='none',$options=array()){
		if(!isset($options['shadow'])){$options['shadow']=1;}
		$fields=$this->exclude_fields($fields,$exclude_fields);
		$h=$this->get_i18n_list($fields);
		//p2($h);
		if($title !=''){
			$title=$this->get_i18n_text($title,'');
		}
		$q=$this->foreign_select(array(
			'get_fid'=>0,
			'fields'=>$fields,
			'restrict'=>$restrict));
		$items=$this->q2obj($q['sql']);
		$this->fs_options=$q;	


		//this section returns an array like <table_name>_<field_name> => fiels_name , so we can correctly address the headers @ foreign_field data
		$hh=array();
		foreach($q['qfields'] as $k=>$f){
			$hh[$f['q']]=$h[$f['simple_name']];
		}
		//p2($hh,'red');

		if($filter!='none'){
			$items=$this->filter_trough($items,$filter);
		}

		return($this->g_table($items,$hh,array(
			'style'=>'gtable',
			'cellspacing'=>0,
			'border'=>1,
			'cellspadding'=>4,
			'shadow'=>$options['shadow'],
			'title'=>$title
		)));
	
	}

	/**
	 * @param $field:	a field structure
	 *
	 * determines if a field is from another table, looking for _id at the end or at the [foreign] key.
	 * it also checks that the field isnt "my_id"
	 *
	 * you can disable field foreign, for instance, if you have a field called: USRID, 
	 * and you don't want that field to be foreign, just add is_foreign=0 to the field definition.
	 *
	 * */
	function field_is_foreign($field){
		if($field==''){
			$this->error("ERROR GRAVE field_is_foreign(): El campo: ".gp2($field).' est vacio!'.b2(),'std076');
		}
		if(!is_array($field)){

			die('EL CAMPO: no es Estructura:'.gp2($field).b2());
		}

		$c=0;
		if($field['name'] == $this->id ){return(0);}

		if(array_key_exists('is_foreign',$field) && $field['is_foreign'] == 0){
			return(0);
		}
		if($this->is_id($field['name'])){
			//$this->log("i think ".$field['name']." is foreign since it has a is_id()",8);				
			return(1);
		}
		if(is_array($field) && array_key_exists('foreign',$field)){
			//$this->log("i think ".$field['name']." is foreign since it has a FOREIGN FIELD",8);
			return(1);
		}
		return(0);
	}
	function app_name(){
		global $std_app_name;
		return($std_app_name);
	}
	/** \brief loads the base module 
	 *
	 * if you need to load modules from places other than your current directory,
	 * use load_module(dir/mod)
	 *
	 *
	 * that's between std and the mods
	 * \todo load input
	 * \todo better error msg
	 *
	 * */
	function load($base_module){
		global $std_app_name;
		$file=$base_module.'_base.php';
		$std_app_name=$base_module;
		if(!file_exists($file)){
			std::i_error('cannot_load_base','std061',array('base_module'=>$base_module));
		}else{
			include($file);
		}
	}
	/**
	 * \todo 232 _id3
	 * removes _id from a string.
	 *
	 * get_foreign_table_from_field get_foreign_table get_foreign get_table 
	 *
	 * @param $field_name the name of the field
	 * if the fields contains no _id at the end, the function will return FALSE
	 * returns mine when mine_id is entered
	 * */
	function id2mod($field_name){
		if(preg_match('/_id$/',$field_name)){
			$tbl=explode('_id',$field_name);
			return($tbl[0]);
		}else{
			return(FALSE);
		}
	}
	/**
	 * this function will tell you whether or not the field was 
	 * "entered" by the user 
	 * (or faked using writing to the $_GET array), which is useful because
	 * this is different for every type, namely: date fields have a special syntax
	 *
	 * @param $field a $field structure @see form::add_field()
	 *
	*/
	function field_is_available($field){
		if($field['type']=='date'){
			if(array_key_exists($field['name'].'_year',$_GET)){
				return(TRUE);
			}else{
				return(FALSE);
			}
		}
		if(array_key_exists($field['name'],$_GET)){
			return(TRUE);
		}else{
			return(FALSE);
		}
	}
	/** 
	 * \todo 302 countless validation schemes., telephone, ac, etc 
	 * \todo 303 validate data within range, make sense feb31
	 * \todo 304 send an error message.
	 *
	 * if you want HTML to be permitted in a certain field, just add to the field allow=>html
	 * @param $data what the user typed
	 * @param $field a field structure, I pass the whole field 
	 * so you can check on datatypes, etc
	 *
	 * \todo 1120 validate data within range, make sense feb31
	 * */
	function validate($data,$field){
		
		$old_data = $data;
		$data=$this->remove_strange_chars($data);

		if($field['type']=='password'){
			$data=md5($data);

		}elseif($field['type']=='date'){
			/** \todo 1120 validate data within range, make sense feb31*/
			
			//THIS WILL BREAK STUFF
			if($data==''){
				$y=$this->remove_strange_chars($_GET[$field['name'].'_year']);
				$m=$this->remove_strange_chars($_GET[$field['name'].'_month']);
				$d=$this->remove_strange_chars($_GET[$field['name'].'_date']);
				$data="$y-$m-$d 00:00:00";
			}else{
				//leave DATA as it were
			}
		}elseif($field['allow']=='html'){
			$data=$this->remove_non_html($old_data);
		}else{
			$data=$data;	
		}
		return($data);
	}
	/** 
	 * @defgroup  field_functions STD:Field Functions 
	 * these functions are all about making the syntax: "usr_id" work, so
	 * that we don't have to manually connect the tables trough the "foreign" key.
	 *
	 * */
	//@{

	/** 
	 * */
	function fields_auto_value($fields,$context){
		if(isset($context['if_not_exists']) && $context['if_not_exists'] == 'create'){
			if(isset($_GET['__auto_field_name'])){
				if(isset($fields[$_GET['__auto_field_name']])){

					$fields[$_GET['__auto_field_name']]['value'] = $_GET['__auto_field_value'];
					if($fields[$_GET['__auto_field_name']]["type"]=='label'){
						#happens twice.
						$fields[$_GET['__auto_field_name']] = $this->field_make_foreign($fields[$_GET['__auto_field_name']]);
						#$fields[$_GET['__auto_field_name']]["display_value"]='nooo';
					}
				}
			}
		}

		return($fields);
	}
	/** 
	 * on after view
	 * */
	function fields_make_multiple($fields,$context){
		
		if(isset($context['multiple']) && $context['multiple'] == '1'){
			if(isset($fields["id"])){
				unset($fields["id"]);
			}
			foreach($fields as $k=>$v){
				
				if($fields["type"]!='hidden' ){
					$fields[$k]['repeat']=1;
				}
				if($this->field_is_foreign($v)){
					$fields[$k]['foreign_links']=0;
				}
			}
		}
		return($fields);
	}

	/**
	 * check if a field has foreign data inside its name, 
	 * like tablename_id or stuff like that,
	 * THIS DOES NOT CHECK FOR field.foreign=table.field
	 * */
	function field_is_deportable($field){
		return($field['name'] != $this->id && ($this->is_id($field['name']) ));
	}

	/** @brief fix field so it displays the right info
	 * adds what it takes to make table_id a array(type=whatever,foreign=table.field)
	 * so we can greatly simplify the eecution process.
	 * it returns the field back, fixed.
	 * \todo 235 some projects have not defined an $ifield, since they are lod syntax, must check for those.
	 * \todo 263 how to support multiple DB interoperation?
	 * @returns a field
	 * */
	function field_deport($field){
		if($this->field_is_deportable($field)){
			$modname=$this->id2mod($field["name"]);
			
			$fm=$this->load_file($modname);
			//$field['foreign']=$fm->table.".".$fm->name;
			$field['foreign']=$fm->table.".".$fm->ifield;
		}	
		return($field);
	}

	/**
	 * this searches for duplicate tables, so we can check if we actually need alias 
	 * functionality,  or can use old fashoned SQL, with no alias 
	 * (which is kinda simpler to work with, and some of  our apps depend on already 
	 * anyway)
	 * */
	function need_alias($which_fields){
			$s=$this->aliased_fields($which_fields);
			return($s[0]);
	}
	/** 
	 * returns @none when nothing is found
	 * @todo 928374 needs some work, support for foreing=>table.name syntax
	 * */
	function get_connector_field($foreign_table){
		foreach($this->fields as $field){
			if($foreign_table.'_id'==$field['name']){
				return($field['name']);
			}
		}
		return('@none');
	}
	/** \brief returns tablename=> XXX, field_name=>yyy, [id=>XXX | id=>0],has_special_connector=[1|0]
	 *
	 *
	 * id=0 mean use default (mod.id), otherwise, connect trough this one!
	 *
	 * foreign field format:
	 * table.name[.connector]
	 * in case coonnector is not given the mod's id is used.
	 * \todo 265 if all info is given, do we *need* to load the mod?,
	 * what if it doesn't exists?
	 * what if we don't want it?
	 * @
	 * */
	function explain_foreign_field($field_name){
		$f=explode('.',$field_name);
		if(count($f)==2){
			//standard connector
			$y=0;
			$sp=0;
		}else{
			$sp=1;
			$y=$f[2];
		}
		return(array('table'=>$f[0],'field'=>$f[1],'id'=>$y,'has_special_connector'=>$sp));
	}
	/** 
	 * \brief whether you need aliases or not
	 *
	 * \todo 236 IMPLEMENT THIS FUNCTION:which field are aliased aliased_fields()???
	 * @param $which_fields A field list structure
	 * \returns an array:
	 - 0 whether you need aliases or not
	 - 1 the fields translated.
	 	alias=>field
	 * */
	function aliased_fields($which_fields){

		$use_alias=0;
		$aliased=array();			
	//	p2($which_fields);
		#$this->log("NEED ALIAS: fields:".count($which_fields),0);
		$used_mods=array($this->table);
		if(!is_array($which_fields)){
			$this->log("SEVERE:fields are some how WRONG:.".$which_fields."..",'WARNING');
			return(array($use_alias,$aliased));
		}

		foreach($which_fields as $k=>$field){
				if($this->field_is_deportable($field) && $this->field_is_foreign($field)){
					$field=$this->field_deport($field);
				}
				if($this->field_is_foreign($field)){
					#stuff is already in spected format
					#fields are not DEPORTED

					$this->log("FIELD $k IS FOREIGN; SINCE:field foreign:".$field['foreign'],'FOREIGN');
					$f3=$this->explain_foreign_field($field['foreign']);
					$modname=$f3['table'];
					if(in_array($modname,$used_mods)){
						$this->log("im using alias because of repeated table in field:$k,".in_array($modname,$used_mods)."mn:".$modname.$used_mods,'FOREIGN');
						$use_alias=1;
						break;
					}
					#$this->log($modname." not in ".implode(",",$used_mods),2);
					$used_mods[$modname]=$modname;
				}else{
				
					#$this->log($k." is not foreign",2);
				}
				
				
			}
		#$this->log("@view:use alias:$use_alias",0);
		return(array($use_alias,$aliased));
	}
	//@}
	
	/** var_dump() with line break fix */
	function win_var_export($var1,$op){
		return(str_replace("\n","\r\n",var_export($var1,$op)));
	}
	
	/**
	 * \brief  turns "all" into the list of fields
	 * \todo 238 can we extend this concept,  into stuff like: ac* -> ac_a ac_b ac_c, or variable fieldes, etc?
	 * */
	function view_expand($fields){
		if($fields=='all'){
			return($this->fields);
		}
		return($fields);
	}
	function get_view_dataset($view){
		$fs = $this->foreign_select($view);
		$sql = $fs['sql'];
		$q2 = $this->reduce_fs($this->q2obj($fs['sql']),$fs,$view['fields']);
		if(isset($view["filter"])){
			$q2 = $this->filter_trough($q2,$view["filter"]);
		}
		return($q2);
	}
	
	/** \brief  adds a field to a view.
	 *
	 * pretty handy.
	 *
	 * SIDE EFFECT: it expands the list, if "all" is found instead.
	 * 
	 * the added fields will be markes _is_added by the function, so you can tell them apart later.
	 *
	 * 
	 * WARNING: fields added this way will NOT be kept into consideration for the 
	 * SQL select UNLESS they have a "name".
	 * \todo 239 poc view FIELD.name: 1+1 :
	 *
	 * @param $field a field structure
	 * 
	 * it is recommended that the field has a name key.
	 *
	 * @param $view_name the name of the view, which must belong to this item
	 *
	 * */

	function add_to_view($view_name,$field){
		global $std_views;
		//in list
		if(!array_key_exists('name',$field)){
			//WE NEED A NAME
			$field['name']='__added_field'.$this->added_fields_count;
			$field['_is_added']=1;
			$this->added_fields_count++;

		}
		/** 
		 * unless the user specifies that he WANT this field, we will remoove it from the file_sql even 
		 * if IT has a name.
		 * */
		if(!array_key_exists('_is_added',$field)){
			$field['_is_added']=1;
		}

		if(array_key_exists($this->table,$std_views)){
			if(array_key_exists($view_name,$std_views[$this->table])){
				//if all, expand
				$std_views[$this->table][$view_name]['fields']=$this->view_expand($std_views[$this->table][$view_name]['fields']);
				$std_views[$this->table][$view_name]['fields'][$field['name']]=$field;

			//shared
			}elseif(array_key_exists($view_name,$std_views['std'])){
				//it's a shared view! (you bastard!)
				//RFC THIS CAN BE USE NI PLACES LIKE: BASE
				$std_views['std'][$view_name]['fields'] = $this->view_expand($std_views['std'][$view_name]['fields']);

				$std_views['std'][$view_name]['fields'][$field['name']]=$field;
			}else{
				$this->log('no shared view:'.$view_name,'ERROR');
			}
		//in shared
		}elseif(array_key_exists($view_name,$std_views['std'])){
			//it's a shared view! (you bastard!)
			//RFC THIS CAN BE USE NI PLACES LIKE: BASE
			$std_views['std'][$view_name]['fields'] = $this->view_expand($std_views['std'][$view_name]['fields']);
			$std_views['std'][$view_name]['fields'][$field['name']]=$field;
		}else{
			$this->log('no such shared view:'.$view_name,'ERROR');
		}

		///p2($std_views[$this->table][$view_name]);
	}
	/** current message */
	function set_cmessage($text){
		global $mydir;		
		$_SESSION[$mydir]["_message"] = $text;
	}
	/** current message */
	function append_cmessage($text){
		global $mydir;		
		$_SESSION[$mydir]["_message"] .= $text;
	}
	/** current message */
	function get_cmessage(){
		global $mydir;
		return($_SESSION[$mydir]["_message"]);
	}
	/** returns current message,and deletes it. */
	function pop_cmessage(){
		global $mydir;
		$dx=$_SESSION[$mydir]["_message"];
		$_SESSION[$mydir]["_message"]='';
		return($dx);
	}
	/**\brief add field
	 * fields must have a name.
	 * @param $f a field structure
	 * */
	function addf($f){
		$this->fields[$f['name']]=$f;
	}
	
	/**
	 * @defgroup  HBM Has Many And Belongs to Many
	 *
	 * */
	//@{
	/**
	 * @ingroup HBM 
	 * this one gets a list of fields, for HBM. 
	 * mode:create,edit . record_id: -1 on create, a valid number any other time
	 * */
	function hbm_fields($record_id,$mode='create'){
		$fields=array();
		//determine kids.
		////todo function have_relations()
		if(is_array($this->rel) && array_key_exists("hbm",$this->rel)){

			//hbm key: the name of the target table, 
			//hbm value: connecting table.	
			foreach($this->rel["hbm"] as $foreign_table=>$connector_table){
				//WARNING: TODO how to make a model unique instance, for foreign purposes?	
				//TODO condition? here?	, makes a LOT of sense!
				//what for?

				$m=$this->load_file($foreign_table,"light");
				$columns = 1;
				
				#p2($m->meta,'red',$m->program_name());

				if(isset($m->meta["hbm_columns"])){
					$columns = $m->meta["hbm_columns"];
					
				}
				#echo("COLUMNAS: $columns");
				//METAINFO
				$op=$this->q2op("SELECT * FROM ".$m->get_table_name(),$m->id,$m->ifield);

				//@TODO [important] what if there are 100 records? 1000 records? scrolling? ajax? limit? what can we do on those cases?
				//same problem with SELECT: input_list() ... 
				//must think of something!

				$chk=1;
				if(isset($m->meta["hbm_check_all"])){
					$chk = $m->meta["hbm_check_all"];
				}

				if(count($op)>0){
					//breakage possible, when is name of field, consider options...
					$fields[$foreign_table."_list"]=array(
					'name'=>$foreign_table."_list",
					'type'=>"checklist",
					'check_all'=>$chk,
					'columns'=>$columns,
					"is_late_addition"=>1,///@todo document
					"options"=>$op,
					"i18n_text"=>$m->i18n("table_plural"),
					"i18n_help"=>"what can I  put here?"
					//todo configurability?
				);
					$fields['__view_hbm']=array(
						"is_late_addition"=>1,
						'type'=>'hidden','name'=>'__view_hbm','value'=>1);					
				}else{
					$this->log("no options were added HBM:$foreign_table","REL");
				}
			}

		}
		
		return($fields);
	}//end determine kids...
	//@}

	/** \brief ed=edit show an edit form
	 *
	 * options.style is now deprecated 
	 * this echoes the output of get_ed, @see std::get_ed() 
	 * */
	function ed($options){

		$this->f=$this->get_ed($options);
		///p2($this->f,'blue','This: f');
		if(!array_key_exists('style',$options)){
			$options['style']=$this->default_style;
		}
		
		$w=(array_key_exists('width',$options))?'width:'.$options['width']:'';
		//style="'.$w.'"
		//align=center
		//echo('<center><div class="cool_container ed_container"  >');
		$this->shadow($this->f->out(),$options['style'],'center');
		//'negative'
		//echo('</div></center>');
	}
	
	/** @defgroup filters Filters
	 * \page filter Filter
	 *
	 * Filters are functions that allow you to easily change columns from the std_view table views
	 * but keeping the logic layer separate.
	 *
	 * parameters:
	 *
	 - $number: a number of line, (usually from 1 to 10) so you can do nice coloring stuff on it
	 - $record an array, containing the record, that was estracted from the database.


	 * a note on filters:
	 * if you edit information that is not in the view list, 
	 * you must check for item existence first.
	 * 
	 * \todo 1123 example code!
	 
	 * */

	//@{

	/** @brief  this will add all kinds of links.
	 *
	 *
	 * \todo this goes in the ME section?
	 * \todo other filters, in the View section?
	 *
	 * \todo filter_link 241 how do we disable this?
	 *
	 * this will add privileges to those links, so be carefull on what you allow here.
	 *
	 * \todo filter_link 1122 link class?
	 *  */

	function filter_link($number,$record){
		///
		///if($GLOBALS['dlog']!=1){$GLOBALS['dlog']=1;$this->e_table(debug_backtrace());}
	//	p2($record);
	//	p2($this->ml_options,'purple');
	//	p2($this->fs_options,'',2,'HEllo');
		$fn=$this->table.'_'.$this->ifield;
		//echo($fn);
		
		//put the "me" link
		
		if(is_array($this->default_edit_action)){
			$action = $this->default_edit_action['action'];
		}else{
			$action = $this->default_edit_action;
		}

		if(array_key_exists($fn,$record)){
			$record[$fn]=$this->make_link(array('mod'=>$this->program_name(),'ac'=>$action,'id'=>strip_tags($record[$this->table.'_'.$this->id])),$record[$fn],'name_column_link');
		}

		//put the foreign links
		if(is_array($this->fs_options['qfields'])){
			foreach($this->fs_options['qfields'] as $k=>$field){
				if($field['was_added']==1){//was added

					$fn=$field['q'];
					//foreign Id
					$fid=$field['foreign_id'];
					//FIX allow user to set this:
					//THIS DOES NOT WORK ON FIELDS THAT ARE "NOT THE KEY"
					//like por_hacer.tiempo
					//must create a view find by field name: field name, value
					//todo6

					$m=$this->load_file($field['table']);
					if($this->privilege_manager->is_allowed($m->program_name().'/'.$m->default_edit_action)){
					$record[$fn]=$this->make_link(array(
						'mod'=>$m->program_name(),
						'ac'=>$m->default_edit_action,
						'id'=>$record[$fid]),$record[$fn],'foreign_column_link');
					}
				}
			}
		}
		return($record);
	}
			
	function filter_mask($number,$record){

		foreach($this->fs_options['qfields'] as $k=>$f){
			$f2 = $this->ml_options['fields'][$k];
			if(array_key_exists('mask',$f2)){
				$record[$f['q']]=str_replace("%%",strip_tags($record[$f['q']]),$f2['mask']);
			}
		}

		return($record);
	}
	/**
	 * requires fs_options to be set
	 * */
	function filter_money($number,$record){
		foreach($record as $k=>$v){
			//echo($v.' '.(int)is_float($v).'/');
			foreach($this->fs_options['qfields'] as $field_name => $qfield){
				if($qfield['q'] == $k){
					if(isset($this->fields[$field_name]['money']) && $this->fields[$field_name]['money'] == '1'){
					//if(preg_match('/^[\d.]+$/' , $v)){
					$record[$k]='<div class="std_num">' . number_format($v, 2, '.', ',')."</div>";
					//}
					}
					break;
				}
			}
		}
		return($record);
	}
	/** \brief do nothing, return it's input
	 *
	 *  this is a dummy filter, its purpose is to do NOTHING to an array that's passed to it,
	 *  and then return the array, this is used as a part of the system that allows you to 
	 *  filter anything that goes trough std::ml() (all the views(), that is, *your* custom defined views.)
	 *
	 *  */

	function filter_none($number,$record){
		///
		///if($GLOBALS['dlog']!=1){$GLOBALS['dlog']=1;$this->e_table(debug_backtrace());}
		return($record);
	}
	/** \brief uses this.current_search[words] to highlight certain search words on a page.
	 *
	 * those that are only searched on ONE column, 
	 * are highlited in only ONE column
	 * */
	function filter_highlight_search_terms($number,$record){
		//$this->e_table($this->current_search);
		foreach($this->current_search['words'] as $k6=>$search_term){
			$f=$this->current_search['fields'][$k6];
			if($f=='*'){
				//highlight all fields
				//echo('<br/>ALL:'.$search_term);
				foreach($record as $k=>$field1){
					if($k==$this->table.'_'.$this->id || $k=='__actions'){
				
					}else{
						$record[$k]=preg_replace(
							$search_term,
							$this->current_search['high'][$k6],
							strip_tags($field1)
							#htmlspecialchars($field1)
						);
					}
				}
				
			}else{
			
				//just highlight one field.
				if($f==$this->table.'_'.$this->id || $f=='__actions'){
			
				}else{
					//echo('<br/>Field:'.$f.' replaces:'.$search_term);
					$record[$f]=preg_replace(
					$search_term,
					$this->current_search['high'][$k6],
					$record[$f]);
					
					
				}
			}
		}
		////OLD
		//$record[$k]=preg_replace($this->current_search["words"],$this->current_search["high"],$v);

		$record=str_replace(array('{{','}}'),array('<span class="hst">','</span>'),$record);
	//	p2($record,'red');
		return($record);
	}
	/**
	 * date fix will display just YMD, and keep hms visible when the user hover over it.
	 */
	function filter_date($number,$record){
		foreach($record as $k=>$date){
			//convert back usr_id to id.
			$d=array_search($k,$this->fs_options['sql_fields']);

			if($this->fields[$d]['type']=='date'){
				#$s=preg_split("/(.*)((\d{4,4})-(\d{1,2})-(\d{1,2})) ((\d{1,2}):(\d{1,2}):(\d{1,2}))(.*)/",$date);
				#p2($s);
				$s=explode(' ',strip_tags($date));
				$record[$k]='<span title="'.strip_tags($record[$k]).'">'.$s[0].'</span>';
				//$record[$k]='<span title="'.$record[$k].'">'.$s[0].'</span>';
			}
		}
		return($record);
	
	}	
	/** \brief cosmetic adjustments 
	 *
	 * this is the default filter, which will do some minor cosmetic adjustements, for list table output.
	 * if you don't like your strings trimmed, change $this->default_filter='your function of preference' in _base
	 *  */
	function filter_trim($number,$record){
		foreach($record as $k=>$v){
			if(strlen($v)>=$this->default_trim_length){
				$record[$k]=substr($v,0,$this->default_trim_length).$this->default_trim_append_string;
			}
		}
		return($record);
	}
	/** \brief run filters trough an array, and return the modified array.
	 *
	 *
	 * @param $l a bi-dimensional array
	 * @param $filters a function name, or an array 
	 * of function names, to be executed
	 *
	 * */
	function filter_trough($l,$filters){
		if(is_array($filters)){
		
		}else{
			$filters=array($filters);
		}
		foreach($filters as $f=>$filter){
			if($filter==''){
				$filter='none';
			}
			
			$func="filter_$filter";
			for($i=0;$i<count($l);$i++){
				$l[$i]=$this->$func($i,$l[$i]);
			}
		}	
		return($l);
	}
	
	//@}	
	
	/** 
	 * \todo 2 242 remove dependencies with foreign_select
	 * \brief this fetches old entered values from all over the place.
	 * */
	function restore_value($input_name){
		if(!array_key_exists($input_name,$_GET)){
			$v='';
		}else{
			$v=$_GET[$input_name];
		}
		return($v);
	}

	/** \brief field list to SQL, for SELECT clause (select ... from )
	 * recieves a fields list structure
	 * @param $field_list a list of fields (same format as $this->fields)
	 * @returns a comma separated list of fields suitable for SQL queries, (like INSERT?)
	 * ignoring (of course) the _is_added fields, 
	 * @see std::add_to_view()
	 * those fields are usually HBM fields anyway.
	 *
	 * */
	function fields_sql($field_list){
		$fields_sql=array();
		foreach($field_list as $k=>$field){
			//determine if field was added, we don't want this stuff.
			if(strpos($field['name'],'__added_field')!==0){
				#if(!is_array($field)){
				#	p2($field,'red');
				#	$this->shadow((b2()));
				#	die();
				#}
				if(!array_key_exists('_is_added',$field) || $field['_is_added'] != 1){
					$fields_sql[$k]=$field['name'];
				}
			}
		}
		return(implode(" ,\n ",$fields_sql));
	}

	
	/**
	 * @defgroup View_Handlers View Handlers 
	 * These functions act like handlers that can be used in views, and
	 * in the creation of new view types, so you can have a view type "grid", "calendar", etc.
	 * al the view handlers, must assume menu() has already been called.
	 * */


	//@{
	function default_sql_filter($table_name){
		return(" 0=0 ");

		#$qf = $this->q2op("SELECT sql_filter from userfilter WHERE usr_id='".ssid()."' and reporte='".$table_name."'",'sql_filter','sql_filter');

	}
/**
	query con subtotales
	
	mysql> select 3 as BREAKLVL,predio.nombre, rodal.nombre, area_total from rodal,p
redio where predio.id = predio_id union             select 2 as BREAKLVL, concat
(predio.nombre,' - Total'),NULL,sum(area_total) FROM predio,rodal where rodal.pr
edio_id = predio.id group by predio.nombre
                                                      union select 1 as BREAKLVL
,NULL,NULL,sum(area_total) from predio,rodal where predio.id = predio_id order b
y 2;

*
 * */	
	function vh_3dchart($view){
		global $config;
		require_once(STD_LOCATION."include/std_3dchart.php");
		return($results);
	}
	function vh_pivot_table($view){
		
		require_once(STD_LOCATION."include/std_pivot.php");
		$p = new std_pivot();
		$ptable = $view;
		$p->title=$view["title"];
		$p->set_data_source($ptable["table"]);
		foreach($ptable["row_fields"] as $f){
			$p->add_row_field($f,$f);
		}
		foreach($ptable["column_fields"] as $f){
			$p->add_column_field($f,$f);
		}
		foreach($ptable["data_fields"] as $f){
			#if($f=='1'){
			#	$label=' ';
			#}else{
			#	$label = $f;
			#}
			#echo("LABEL IS:$label");
			$p->add_data_field($f);
		}
		if(isset($ptable["restrict"])){
			$p->add_restriction($ptable["restrict"]);
		}
		$p->add_restriction($this->default_sql_filter($ptable["table"]));
		if(isset($ptable["parameters"])){
			$p->parameters = $ptable["parameters"];
		}

		if(isset($ptable["gt0"])){
			$p->only_columns_greater_than_zero=$ptable["gt0"];
		}
		return($this->get_shadow($p->out()));
	}
	
	function vh_chart($view){
		include(INCLUDE_DIR."chart.php");
		return($result);
	}
	/** 
	 * this is a lovely one liner, one step below from DSL, one step avobe from ac_your_code, simple!
	 *
	 * */
	function vh_rawsql($view){
		$result = $this->shadow($this->table($this->q2obj($view["sql"]),'none',array('border'=>0,'style'=>'list','title'=>$view["title"])));
		return($result);
	}
	function vh_hierarchy($view){
		include(INCLUDE_DIR.'hierarchy.php');
		return($result);
	}
	function vh_query($view){
		include(INCLUDE_DIR.'query.php');
		return($result);
	}
	function vh_sqlquery($view){
		include(INCLUDE_DIR.'sqlquery.php');
		return($result);
	}
	/** 
	 * vh tree: permits trees
	 * */	
	function vh_tree($view){
		include(INCLUDE_DIR.'tree.php');
		return($result);
	}
	/** 
	 * vh feed: allow RSS, ATOM, ETC (now supported: feed_type attribute, with rss (smallcaps) the only valid paramter)
	 * @todo 1200 must fix: get_view_contents()
	 * */	
	function vh_feed($view){
		include(INCLUDE_DIR.'feed.php');
		$v=new feed($this,$view);
		$v->get_feed();
	}
	/** 
	 * vh report
	 * @todo 1200 must fix: get_view_contents()
	 * */	
	function vh_report($view){
		include(INCLUDE_DIR.'report.php');
		$v=new report($this,$view);
		$v->display_report();
	}
	/**
	 * View Handler Table: allows you to see a number of items, and controll them.
	 * it also saves the search in session, so we can use b2l
	 * */
	function vh_table($view){
		global $mydir;
		include_once(INCLUDE_DIR.'std_view.php');
		$v=new view($this,$view);
		
		#save search in session.
		$_SESSION[$mydir]["usr"]["_search"][$this->program_name()]=$_GET;
		$_SESSION[$mydir]["usr"]["_last_list"]=$_GET;
		return($v->ml());
	}
	/**
	 * View Handler Simple: more than dsl, less than ml
	 * */
	function vh_simple($view){
		global $mydir;
		include_once(INCLUDE_DIR.'simple.php');
		return($result);
	}

	/** grid view
	 * \todo finish 
	 * */
	function vh_grid($view){
		#simple, uh
		global $mydir;
		echo("Welcome to the jungle");
		$this->ml($view);
		#save search in session.
		$_SESSION[$mydir]["usr"]["_search"][$this->table]=$_GET;
		$this->log("Saved search");

	}
	/**
	 *	\todo save register,  in Session, then check if the information is the same, before insert, if different, warn about changes.
		\todo on view myself, there must be a , that send you to edit2own, so you cant tamper that either. listown / editmyself, that checks that you dont edit other's people stuff
		
		recieves parameters:
		actions	an array of actions (actions must be coded in )
		title		the title of the form (key of i18n)
		fields:	an array of fields.
				each field is a Field Structure
		\todo allow foreign with ranges.
		WARNING: this function used to warn about new fields, it no longer does, please keep that in mind.
	 * */
	function vh_record($view){
		global $i18n_std,$i18n;

		$id=$this->remove_strange_chars($_GET['id']);
		$fields_sql=$this->fields_sql($view['fields']);

		if($view["if_not_exists"]=='create'){
			#We are on an INSERT view
			$data=array();
			
			foreach($view["fields"] as $k=>$field){
				if($this->id==$field['name']){
					$view['fields'][$k]["type"]='hidden';#DO NOT DISPLAY ID, its an insert, pal!
				}
				$data[0][$field['name']]=$field['value'];#could be nothing...
			}

		}else{
			#this is an UPDATE, failed because no such record exists on DB
			if(array_key_exists('restrict',$view)){
				$r=" AND ".$view['restrict'];
			}else{
				$r='';
			}
			$data=$this->q2obj("SELECT $fields_sql FROM ".$this->get_table_name()." WHERE ".$this->id." ='$id' ".$r);
			if(count($data)==0){

				$this->i_error('no_such_record','std060');
				return(0);
			}	
		}


		#this is an update

		$view["data"]=$data;
		//FILTER
		if(isset($view["filter"])){
			$view["data"] = $this->filter_trough($view["data"],$view["filter"]);
		}
		$f = $this->get_ed($view);
		
		$r = $f->out();
		if($view['show_shadow']!='none'){
			$r = $this->get_shadow($r,'shadow','center','60%');
		}else{
			
		}
		return($r);
	}
	//@}

	function get_view_list(){
		return(array_keys($this->get_views()));
	}
	function get_shared_views(){
		global $std_views;
		return($std_views['std']);
	}
	/** \todo 243 how are specifid views inside files handled? */
	function get_views(){
		global $std_views;
		$a=$this->get_shared_views();
		if(!array_key_exists($this->program_name(),$std_views)){
			return($a);
		}
		$g = glob("./view/".$this->program_name().'/*.view.php');
		$file_views=array();
		if(is_array($g) && count($g)>0){
			foreach($g as $view_file){
				$vn = basename($view_file,'.view.php');
				$file_views[$vn]=$this->load_view($this->program_name(),$vn);
			}
		}
		
		
		return(array_merge(array_merge($a,$file_views),$std_views[$this->program_name()]));
	}
	/**
	 * @defgroup module module utilities
	 *
	 * */
	//@{
	/** \brief retrieves a list of valid modules for the current directory.
	 *
	 *
	 * It also finds the shared modules.
	 * this is done by globbing the directory.
	 * this is useful because if I change the location of controller, to mod
	 * should I ever need to do so, this is one of the few places I will
	 * ever need to change in order to achieve so.
	 * \todo 244 make that possible [config?]
	 * $mode: controller, or i18n, or whatever
	 * */
	function get_valid_modules($dir='.',$mode='controller'){
		return(array_merge($this->get_local_modules($dir,$mode),array()));//$this->get_shared_modules($dir,$mode)
	}
	/**
	 * */
	function get_local_modules($dir='.',$mode='controller'){
		return(glob($dir.'/'.$mode.'/'.'*.'.$mode.'.php'));
	}
	/**
	 * */
	function get_shared_modules($dir='.'){
		return(glob(SHARED_MODULES_DIR.'controller/'.'*.controller.php'));
	}
	function get_valid_i18n($dir='.'){
		return(array_merge($this->get_local_i18n($dir),$this->get_shared_i18n($dir)));
	}
	/**
	 * */
	function get_local_i18n($dir='.'){
		return(glob($dir.'/i18n/'.std_get_language().'/*.i18n.php'));
	}
	/**
	 * */
	function get_shared_i18n($dir='.'){
		return(glob(SHARED_MODULES_DIR.'i18n/'.std_get_language().'/*.i18n.php'));
	}

	//@}
	/** \brief all the valid actions for all the modules.
	 * */
	function all_valid_actions(){
		$mod_list=$this->get_valid_modules();
		$a=array();
		foreach($mod_list as $k=>$f){
			$module_name=basename($f,'.controller.php');
			$f9=$this->load_file($module_name);
			$a[$module_name]=$module_name;
			$this->log("<h1>mod:$module_name</h1>",'VALID');
			foreach($f9->get_valid_actions() as $k2=>$fn){
				$qfn=$module_name.'/'.$module_name."#".$fn;
				$basename=$fn;
				$a[$qfn]=$f9->get_i18n_text($basename).' ('.$basename.')';
			}	
		}
		//d2($a);
		return($a);
	}
	/**
	 * this will load a "load on runtime" function
	 * such functions are inside the /core/func dir
	 * check any of those files for reference on how to create load-on-runtime functions.
	 * */
	function load_external(){
		$modules = func_get_args();
		foreach($modules as $k=>$v){
			include_once(STD_LOCATION."func/$v.func.php");
			$le=func_get_args();
			//$this->log('loaded:'.implode(',',$le),'STD1');
		}
	}
	/**
	 * whether or not this has foreign kids
	 * */
	function has_kids($id){
		return($this->kids_count($id)>0);
	}
	/** 
	 * returns a sum of all the table foreign kids, from all the tables.
	 * */
	function kids_count($id){
		$c=0;
		foreach($this->child_array($id) as $c2){
			$c+=$c2;
		}
		return($c);
	}
	/**
	 *  returns an array, 
	 *  [table_name=>kid_count]+
	 *  @todo add hbm
	 *  */
	function child_array($id){
		$ret=array();
		if(isset($this->rel['has']) && is_array($this->rel['has'])){
			$a=$this->rel['has'];
		}else{
			$a=array();
		}

		if(isset($this->rel['hbm']) && is_array($this->rel['hbm'])){
			foreach($this->rel['hbm'] as $foreign_table=>$conection_table){
				$a[$conection_table]=$conection_table;
			}
		}
		
		foreach($a as $table){
			$m=$this->load_file($table);
			$m->fields=$m->fields_transform($m->fields,array());
			foreach($m->fields as $name=>$field){
				if($m->field_is_foreign($field)){
					$mod2=$this->id2mod($name);
					if($mod2==$this->program_name()){
						//These are related
						$op=$this->q2obj('SELECT count(*) as c FROM '.$m->get_table_name().' WHERE '.$name.' = \''.$id.'\'');	
						$ret[$table]=$op[0]['c'];
						break;
					}
				}
			}
		}
		return($ret);
	}

	/** 
	 * @defgroup events Events
	"before_*" events must return true, so that the actions occurs.
	 * */
	//@{
	
	function on_before_delete(){
		$id=$this->remove_strange_chars($_GET['id']);
		return($this->has_kids($id)==FALSE);
	}
	function on_before_delete2(){
		return(true);
	}
	function on_before_delete_selected(){
		$allok=0;
		if(isset($_GET['item']) && is_array($_GET['item'])){
			foreach($_GET['item'] as $id){
				$id=$this->remove_strange_chars($id);
				$allok = $this->has_kids($id) || $allok;
			}
		}
		return($allok==FALSE);
	}

	function on_after_delete_selected(){
		return(true);
	}
	function on_before_edit2(){
		return(true);
	}
	function on_after_new2(){
		return(true);
	}
	function on_before_new2(){
		return(true);
	}
	/** 
	 * WARNING: the contents of this function will not be OUTPUTTED, but RETURNED,
	 * so don't even try to echo() anything from here, it will only lead to a headache.
	 *
	 * */
	function on_after_view(){
		return("");
	}
	/** before view and menu*/
	function on_before_view(){
		return(true);
	}
	/** between view and menu*/
	function on_before_view_display(){
	
	}

	function on_after_xls(){
		return(true);
	}
	function on_before_xls(){
		return(true);
	}

	function on_after_edit2(){
		return(true);
	}
	function on_after_delete(){
		return(true);
	}
	function on_after_delete2(){
		return(true);
	}

	//@}

	/** 
	 * @defgroup view_functions STD:View Functions 
	 * a view, is a collection of fields, restrict, etc
	 * @see std::get_view
	 * @see std_view
	 * see func/get_view
	 * @see std::run_view
	 *
	 * */
	//@{

	/** 
	 * show a view, no menu 
	 * @param $view_name the name of the view.
	 * @see ac_view()
	 * */
	function run_view($view_name){
		//save enviroment
		$ca=$this->current_action;
		$cv=$this->current_view;
		$sm=$this->show_menu;

		//$this->current_action='view:'.$view_name;
		$this->current_view=$view_name;
		$this->show_menu=0;
		$this->ac_view();
		//restore enviroment
		//should i restore $this-fs_options, and this.f ??????
		$this->current_action=$ca;
		$cv=$this->current_view=$cv;
		$sm=$this->show_menu=$sm;

	}
	function get_view($name){
		global $std_views;
		return(new viewport($std_views[$this->table][$name]));
	}
	function fetch_any_of($file_list){
		foreach($file_list as $file){
			if(file_exists($file)){
				return($file);
			}
		}
		return(FALSE);
	}
	/** 9876 
	 * @param $mod a table name
	 * @param $dir (default: this one), the module might reside in another folder
	 * (useful for inter app communication)
	 * this loads the module's views, and it also loads a view from the
	 * /view/table.view.php file, if it exists.
	 * it also loads any shared view that might be available.
	 * @see std::load_file()
	 * @returns the views Structure
	 * */
	function load_module_views($mod,$dir='.'){
		global $i18n,$i18n_std,$std_fields,$std_views;

		$views_file=$dir.'/view/'.$mod.'.view.php';
		if(!file_exists($views_file)){

			$views_file=SHARED_MODULES_DIR.'view/'.$mod.".view.php";
			if(!file_exists($views_file)){					
				#NO longer a problem, since we have SHARED VIEWS,
				#altough, IF your view isn't on the shared ones, 
				#check std075 (@actions/view)

				///\todo 255 wtf is going on here: this is bad?
				//WHY is this loaded 4 times?
				$this->log('no views found!:'.$mod.' FROM:'.$this->table,'VIEW');
				$std_views[$mod]=array();//so noone complains about missing arrays

			}else{
				require_once($views_file);
			}
		}else{
			require_once($views_file);
		}
		return($std_views[$mod]);
	}
	//@}

	/** @defgroup actions Action Handlers
	 * These functions are the default actions
	 * none of this functions is loaded by default,
	 * they reside in /include/actions/action_name.php
	 * if you change their code, make shure you test it, since they won't be checked
	 * until runtime, due to include().
	 *
	 * \todo 249 grid, calendar, etc
	 * */
	//@{	
	
	function ac_tree(){include(INCLUDE_DIR."actions/tree.php");}
	function ac_read_only(){include(INCLUDE_DIR."actions/read_only.php");}
	function ac_read_only_view(){include(INCLUDE_DIR."actions/read_only_view.php");}
	function ac_all(){include(INCLUDE_DIR."actions/all.php");}
	function ac_all_cal(){include(INCLUDE_DIR."actions/cal.php");}
	function ac_all_delete(){$this->ac_delete();}
	function ac_all_delete_selected(){$this->ac_delete_selected();}
	function ac_all_xls(){$this->ac_xls();}
	function ac_all_new(){$this->ac_new();}
	function ac_new(){$this->menu();$this->run_view('new');}
	function ac_all_b2l(){$this->ac_b2l();}
	function ac_all_new2(){global $config;$this->ac_new2();}
	function ac_all_edit2(){$this->ac_edit2();}
	function ac_all_delete2(){$this->ac_delete2();}

	function ac_copy(){global $std_views,$i18n_std,$i18n;include(INCLUDE_DIR."actions/copy.php");}
	function ac_all_image_upload(){global $std_views,$i18n_std,$i18n,$config;include(INCLUDE_DIR."actions/upload_image.php");}
	function ac_all_edit(){global $std_views,$i18n_std,$i18n;include(INCLUDE_DIR."actions/all_edit.php");}
	function ac_main(){global $std_views,$i18n_std,$i18n;include(INCLUDE_DIR."actions/main.php");}
	function ac_gstat(){include(INCLUDE_DIR."actions/gstat.php");}
	function ac_delete_selected(){include(INCLUDE_DIR."actions/delete_selected.php");}
	function ac_b2l(){global $mydir;include(INCLUDE_DIR."actions/b2l.php");}
	function ac_xls(){global $i18n_std,$i18n;include(INCLUDE_DIR."actions/xls.php");}
	function ac_edit2(){global $i18n_std;include(INCLUDE_DIR."actions/edit2.php");return($r);}
	function ac_delete(){global $i18n,$i18n_std;include(INCLUDE_DIR."actions/delete.php");}
	function ac_delete2(){global $i18n,$i18n_std;include(INCLUDE_DIR."actions/delete2.php");}
	function ac_new2(){global $i18n,$i18n_std;include(INCLUDE_DIR."actions/new2.php");return($r);}
	function ac_create(){global $i18n,$i18n_std;include(INCLUDE_DIR."actions/create.php");}
	function ac_view($view_name=''){echo($this->get_view_contents($view_name));}

	//@}

	/**a wrapper for std::grid() */
	function sgrid($fields,$data,$options=array()){
		$this->shadow($this->grid($fields,$data,$options),'shadow','center','50%');
	}
	
	/**
		this generates a small grid so you can edit multiple values at once.
		parameters:
			fields: a list of fields
			data:	a bi-dimensional array with the data
			options:a keyed array with the following options:

				head:	headers for the grid
				table_style
				table_border	
			note: the options array is passed directly to form()
					
	 [] is not automagicaly added to fields, since you might not want it
	 \todo autodetect?
	
	 restrictions: options[] HAS to contain a "strings" key, with the form's strings 
	 (remember, this is simply )
	\todo add nobr
	 * */
		
	function grid($fields,$data,$options=array()){

		$n=new form($fields,$options);
		#$n->strings=$options["strings"];
		$out=array();
		$head=$options["head"];

		$b='';

		foreach($data as $k=>$row){
			
			foreach($row as $k1=>$field_data){
				$n->fields[$k1]["value"]=$field_data;
			}
			$b=$n->bare_fields();
			$out[$k]=$b["visible_fields"];
		}
		return(	$b["head"].
			$this->table($out,$head,array(
				'footer'=>$b["buttons"],
				'title'=>$b["title"],
				'style'=>$options["table_style"],
				'border'=>$options["table_border"],
			)).
			implode("\n",$b["hidden_fields"]).
			$b["foot"]
		);
	}
	/** 
	 * @brief load a module's relationships, 
	 * @see std::load_file() 
	 *
	 * */	
	function load_module_relationships($mod,$dir='.'){
		global $std_rel;

		$rel_file=$dir.'/rel/'.$mod.'.rel.php';
		if(!file_exists($rel_file)){
			//echo("<br />load shared rel file");
			$rel_file=SHARED_MODULES_DIR.'rel/'.$mod.".rel.php";
			if(!file_exists($rel_file)){					
				//$this->i_msg('no_rel_file','std042',array('file'=>$mod));
				$this->log('NO REL FILE FOUND:'.$mod,'ERROR');
				
				return(0);
			}else{
				require_once($rel_file);
			}
		}else{
			require_once($rel_file);
		}
		$this->rel=$std_rel[$mod];
		#$this->log('REL FILE:'.$rel_file.'<br/>REL INFO:'.gp2($std_rel[$mod]),'MODULE');	
	}
	
	/** @brief vdetermine my NAME:
	 *
	 * the NAME is the field that is used in a lot of places, to identify a tables record, think of a name field.
	 * the name is stored in $this->ifield
	 * 
	 * if name is not determined, use the first VARCHAR you see.
	 * */
	function find_ifield(){
		if($this->use_table==1){
			if($this->ifield=='STD_NO_IFIELD'){
				foreach($this->fields as $k=>$field){
					// if name is not determined, use the first VARCHAR you see.
					if($field['name']==$this->id){
					
					}elseif($field['type']=='text'){
						$this->ifield=$field['name'];
						$this->log('ifield found: mod:'.$this->table.' iname:'.$this->ifield,'MODULE');
						break;
					}
				}
				if($this->ifield=='STD_NO_IFIELD'){
					//stil not found, could be a CODE module, leave it alone.
					$this->log('no ifield found for: '.$this->table,'MODULE');
				}
			}
		}
	}
	
	function get_shadow_start($shadow_folder='shadow',$align='left',$width=''){
		if(!is_a($this->shadow_object,'common')){
			$this->shadow_object=new common();
		}

		return($this->shadow_object->get_shadow_start($shadow_folder,$align,$width));
	}
	function get_shadow_end($shadow_folder='shadow',$align='left',$width=''	){
		return($this->shadow_object->get_shadow_end($shadow_folder,$align,$width));
	}


	/**
	 * \page load_file load_file
	 *
	 * modules are table handlers
	 * each module handles a table
	 * modules live in /model, /view and /controller 
	 * \todo 1127 further docs, examples
	 *
	 *
	 * @param $mod the name of the module (no extension, no path, just "usr", or "edit", etc)
	 * @param $mode full: all, light: just model info
	 * @returns the module object
	 this loads a file, and all of its necesary stuff, like language stuff, etc
	 109. the module names are lowercased by default, so make sure all your modules are lowercase.
	 it also prints a nice error mesage when the module is not found
	 this is a lot like base_class::load_module()
	 ahh, the good days...
		
		\todo 256 check if class was created
	 */
	function load_file($mod,$mode='full'){
		global $i18n,$i18n_std,$std_fields,$std_rel,$config,$main;
		#echo("loading:$mod");
		$dir='.';
		$mod=$this->remove_strange_chars($mod);
		//is external
		///\todo 257 change / to # ?
		if(strpos($mod,'/')!==FALSE){
			$parts=explode('/',$mod);
			$dir=$parts[0];
			$mod=$parts[1];
			if(!in_array($dir.'_base',get_declared_classes())){
				require_once('../'.$dir.'/'.$dir.'_base.php');
			}
			$dir='../'.$dir;	//up one level
		}
		if($mod==''){
			$this->error('no mod name given');
			p2(0);//help backtrace
		}
			
		$mod=strtolower($mod);//WARNING:109
		$f=$dir."/controller/".$mod.".controller.php";
		$is_shared=0;
		$model_file=$dir."/model/".$mod.".model.php";
		if(!file_exists($f)){
			//echo("<br />no file seek shared");
			$f=SHARED_MODULES_DIR."controller/".$mod.".controller.php";
			$is_shared=1;
			$model_file=SHARED_MODULES_DIR."model/$mod.model.php";
			
			if(!file_exists($f)){
				//echo("no such file");
				$this->i_error('no_such_module','std040',array('mod'=>$mod));
				return(0);
			}
		}
		
		$this->load_i18n($mod,$dir);
		#echo("views:$views_file");
		#echo($is_shared);
		if(file_exists($model_file)){
			#if the file does not exists, no problem, its a procedural module, not a CRUD module,
			#altough, this WILL make you shoot yourself in the Foot..
			require_once($model_file);
			
		}else{
			$this->log("model file was not found:$model_file",'MODULE');
		}
		require_once($f);
		$mod1=null;
		//OLD code.
		//eval("\$mod1 = new ${mod}_model();");
		$m5=$mod.'_model';
		$mod1=new $m5();
		
		$mod1->std(1);//please, attempt to connect to the database, even of you won't use it
		
		$mod1->load_meta($mod,$dir);

		if($mode=='full'){
			if($mod1->use_table == 1){
				$mod1->load_module_views($mod,$dir);
				$mod1->load_module_relationships($mod,$dir);
			}else{
				$mod1->log($mod.":why should I load rels and views?",'WARNING');
			}
		}else{

		}
		$mod1->is_shared_module_flag = $is_shared;	
		//if($is_shared==1){
		//if($is_shared==1){
			//shared modules usually have the default shadow() stuff, so
			//I'll override the shadow object, so that they look
			//like you'r app's modules
			$mod1->shadow_object=$main;
		//}
		

		if($mod1->table=='STD_NO_TABLE'){
			//that means: a) is a shared run-only code b) is a new module (0274+)	
			//try to figure out a table_name for me.
			$mod1->table=$mod;
		}

		/** 
		 * Table Prefix: if the mod defined its own table_prefix, leave it alone
		 * otherwise, put the Config File table_prefix, if it exists 
		 * this should fix the Shared Modules 
		 * */
		if($mod1->table_prefix=='' && array_key_exists('table_prefix',$config)){
			//$table_prefix
			$mod1->table_prefix = $config['table_prefix'];
		}
		
		$mod1->module_name=$mod;

		//fix table missing problem
		if($mod1->table==''){
			//this is a service module (i hope)
			$mod1->log('no table name','WARNING');
			$mod1->table=$mod1->program_name();
		}

		if($mod1->use_table==1){
			$my_fields=$std_fields[$mod];
			if(!is_array($my_fields)){
				$my_fields=array();//an empty array
			}
			$mod1->fields=$mod1->parse_model_info($my_fields);
		}else{
			$mod1->fields=array();
		}
		///$mod1->rel=$std_rel[$mod];
		$mod1->find_ifield();

		//initialize module excecution

		$mod1->mod_init();

		//table
		return($mod1);
	}
	/** 
	 * overwrite this if you want VERY special behavior
	 * */
	function app_init(){
		$this->load_current_module();
	}
	function create_form(){
		$d=new form();
		$d->set_shadow_object($this);
			
	}
	function parse_special_values($field_array){
		foreach($field_array as $kfield=>$field){
			if(is_array($field) && array_key_exists('value',$field)){
				$field_array[$kfield]['value']=$this->fmt($field['value'],
						array(
							'uid'=>ssid(),
							'now'=>date('Y-m-d H:i:s'),
							'today'=>date('Y-m-d'),
							'now_hms'=>date('H:i'),
						)
					);
			}
		}
		return($field_array);
	}
	/** 
	 * override on base so you can add new parameters to all the modules in your app, and a custom action for
	 * handling those params.
	 * NAME can be missing, the key name is assumed.
	 *
	 * available keys for mane formatting are: uid,now
	 * \todo 262 allow user to set more add_key?()
	 * */
	function parse_model_info($field_array){
		global $i18n;
		if($this->nomodel==1){
			$field_array=array();
			foreach($this->describe($this->table) as $r){
				$field_array[$r["Field"]]=array('name'=>$r['Field'],'type'=>'text');//@todo add more types 1927938712
				if(!is_array($i18n[$this->program_name()]["fields"])){
					$i18n[$this->program_name()]["fields"]=array();
				}
				$i18n[$this->program_name()]["fields"][$r["Field"]]=ucwords($r["Field"]);
				$i18n[$this->program_name()]["help_".$r["Field"]]=ucwords($r["Field"]);//@todo fetch comment from db?
			}
			$i18n[$this->program_name()]["table_plural"]=ucwords($this->table);

		}
		foreach($field_array as $kfield=>$field){
			if(!array_key_exists('name',$field)){
				$field_array[$kfield]['name']=$kfield;
			}
		}
		$field_array = $this->parse_special_values($field_array);
		return($field_array);
	}
	function ac_rebuild_privileges(){
		$this->privilege_manager->rebuild_privileges();
		$this->menu();
	
	}
	///@defgroup prefix Prefix utilities

	///@{
	
	/** 
	 * each app has a table_prefix, defined in config, and added to all modules, shared or not,
	 * so that you can have a workspace
	 * this makes writhing SQL more troublesome, since the prefixes are everywhere, but has
	 * the advantage of allowing you to have mutiple instances of each application, in the same database.
	 * 
	 * */
	function get_config_prefix(){
		global $config;
		return($config['table_prefix']);
	}	

	function mod_init(){
		$this->table_name=$this->table_prefix . $this->table;
	}

	/** 
	 * @see @ref page1
	 * @see std::get_table_name()
	 * */
	function program_name(){
		return($this->module_name);
	}
	/**
	 * @page page1 a documentation page
	 * all instances of $this->table should be replaces by either this, or std::program_name()
	 * */
	function get_table_name(){
		return($this->table_name);
	}

	//@}
		
	function set_global_current_record($current_record){
		global $std_current_record_id;
		$std_current_record_id= $current_record;	
	}
	function get_global_current_record(){
		global $std_current_record_id; 
		return($std_current_record_id);
	}
	///@defgroup icon Icon Utilities

	///@{
	
	/****/

	function iconize($text,$label){
		$ic=MEDIA_DIR.'icons/'.$text.".png";

		if(file_exists("./media/icons/$text.png")){
			$ic='./media/icons/'.$text .".png";		
		}elseif(file_exists(MEDIA_DIR.'icons/'.$text.".png")){
			$ic=MEDIA_DIR.'icons/'.$text.".png";
		}else{
			$label.=' - not found.';
		}
		return("<img src='".$ic."' alt='$label' border=0 />");
	}
	function resolve_icon($icon){

		$a = array(
			'add_field'=>'add',
			'view_sqlquery'=>'document',
			'view_rawsql'=>'view_rawsqlquery',
			'view_record'=>'application_form',
			'view_table'=>'application_view_columns',
			'view_chart'=>'pie',
			'table'=>'table',
		);
		if(isset($a[$icon])){
			return($a[$icon]);
		}else{
			return($icon);
		}
		
	}
	function icon($text){
		return($this->iconize($this->resolve_icon($text),$text));
	}
	function icon_link($url,$text){
		return("<a href='".$url."' title='".$text."'>".$this->icon($text)."</a>");
	}
	function table2($a,$headers='none',$options=array(),$jsenabled=0){
		$dx='';
		$css='';
		if(isset($options['css'])){
			$css=$options['css'];
		}
		foreach($a as $row){
			$name = $row["name"];
			if(isset($row["icon"])){
				$icon= $this->resolve_icon($row["icon"]);
			}else{
				$icon= 'page_white';
			}
			$dx.='<div style="float:left" id="">';
			$dx.='<div class=std_icon style="'.$css.'">';
			if($jsenabled==0){
				$param='href';
			}else{
				$param='onclick';
			}
			$dx.='<a class="standard_link icon_link" '.$param.'="'.$row["url"].'" title='.$name.' >';
			$dx.=$this->iconize($icon,$name);
			$dx.='<br/>';
			#$row["name"] = str_replace("_","\n",$row["name"]);
			#$dx.=nl2br(chunk_split($row["name"],14,"<br/>"));
			$ax=array();
			$cl=13;
			$i=0;
			$c=0;
			//middle trim
			$ml = 100;
			$row["name"]=ucwords(strtolower($row["name"]));
			if(strlen($row["name"])>$ml){
				$row["name"] = substr($row["name"],0,$ml/2).'...'.substr($row["name"], strlen($row["name"])-$ml/2,$ml/2 );
			}
			while($c<strlen($row["name"]) ){
				$ax[] = substr( $row["name"] , $c , $cl ); 
				$i++;
				$c+=$cl;
			}
			foreach($ax as $k1=>$v1){
				$ax[$k1] = str_replace("_","_ <span></span>",$ax[$k1]);
				$ax[$k1] = str_replace(":",": <span></span>",$ax[$k1]);
			}
			/*
			if(strlen($row["name"])>40){
				$dx.=substr(str_replace(array("_","."),array("_ ",". "),$row["name"]),0,40).'...';
			}else{
				$dx.=str_replace("_"," ",$row["name"]);
			}
			*/
			$dx.=implode("<span></span>",$ax);
			$dx.='</a></div></div>';
			#foreach($row as $cell){
			#	$dx.=($cell);
			#}
			#$dx.=("<br/>");
		}
		return($dx);
	}
	function e_table2($a,$headers='none',$options=array()){
		echo($this->table2($a,$headers,$options));
	}
	///@}
	function ac_random(){
		$this->menu();

		include(STD_LOCATION.'include/random_data_generator.php');
		$r = new random_data_generator();
		$r->generate_random_data($this);
	}
	
}#end std


/**
 * @page widget_overloading Widget Overloading
 * to overload a widget, use this
 * @todo 1130 samples required widget
 * */ 
		
/** 
 * @page install_manager Install Manager
 * @see util_model::install_manager 
* */

